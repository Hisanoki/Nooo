--===== SERVICES =====--
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

local LocalPlayer = Players.LocalPlayer

--===== CONFIG =====--
local DEFAULT_HITBOX_SIZE = 4
local DEFAULT_MOVE_SPEED = 16 -- Tốc độ di chuyển mặc định

-- Colors (light blue theme)
local COLOR_PRIMARY   = Color3.fromRGB(140, 185, 255) -- buttons base
local COLOR_PRIMARY_D = Color3.fromRGB(100, 150, 255) -- darker
local COLOR_ACCENT    = Color3.fromRGB(180, 220, 255) -- strokes/hover
local COLOR_FRAME     = Color3.fromRGB(40, 60, 100)
local COLOR_TITLE     = Color3.fromRGB(30, 50, 90)
local COLOR_INPUT     = Color3.fromRGB(60, 90, 140)
local COLOR_TEXT      = Color3.fromRGB(255, 255, 255)
local COLOR_DANGER    = Color3.fromRGB(200, 80, 80)
local COLOR_GOOD      = Color3.fromRGB(80, 180, 120)

--===== STATE =====--
local processedNPCs = {}     -- [Model] = {connections = {RBXScriptConnection,...}, esp = Instance}
local respawnWatchers = {}   -- [Model] = {RBXScriptConnection,...}
local connections = {}       -- workspace listeners
local autoHitboxEnabled = false
local autoMeshEnabled = false
local moveSpeed = DEFAULT_MOVE_SPEED -- Đổi tên biến
local speedConnection = nil

--===== GUI ROOT =====--
local gui = Instance.new("ScreenGui")
gui.Name = "NPC_Hitbox_GUI_Mobile"
gui.ResetOnSpawn = false
gui.Parent = game.CoreGui

--===== HELPERS =====--
local function disconnectList(list)
	if not list then return end
	for _, c in ipairs(list) do
		pcall(function() c:Disconnect() end)
	end
end

-- create button helper (with hover + press animation)
local function createButton(parent, text, pos, size, baseColor)
	local btn = Instance.new("TextButton")
	btn.AnchorPoint = Vector2.new(0, 0)
	btn.Position = pos
	btn.Size = size or UDim2.fromOffset(220, 32)
	btn.BackgroundColor3 = baseColor or COLOR_PRIMARY
	btn.Text = text
	btn.TextColor3 = COLOR_TEXT
	btn.Font = Enum.Font.GothamBold
	btn.TextSize = 14
	btn.AutoButtonColor = false
	btn.Parent = parent

	local corner = Instance.new("UICorner", btn)
	corner.CornerRadius = UDim.new(0, 8)

	local stroke = Instance.new("UIStroke", btn)
	stroke.Color = COLOR_ACCENT
	stroke.Thickness = 1

	-- hover
	btn.MouseEnter:Connect(function()
		TweenService:Create(btn, TweenInfo.new(0.15), {
			BackgroundColor3 = baseColor:Lerp(COLOR_ACCENT, 0.25)
		}):Play()
	end)
	btn.MouseLeave:Connect(function()
		TweenService:Create(btn, TweenInfo.new(0.15), {
			BackgroundColor3 = baseColor
		}):Play()
	end)

	-- click "press" animation (uses original size)
	local origSize = btn.Size
	btn.MouseButton1Click:Connect(function()
		local down = TweenService:Create(btn, TweenInfo.new(0.08), {
			Size = UDim2.new(origSize.X.Scale, math.max(0, origSize.X.Offset - 6), origSize.Y.Scale, math.max(0, origSize.Y.Offset - 4))
		})
		local up = TweenService:Create(btn, TweenInfo.new(0.08), {
			Size = origSize
		})
		down:Play()
		down.Completed:Wait()
		up:Play()
	end)

	return btn
end

-- Custom draggable for ANY GuiObject (works better than .Draggable)
local function makeDraggable(guiObject)
	local dragging = false
	local dragStart, startPos

	local function update(input)
		local delta = input.Position - dragStart
		guiObject.Position = UDim2.new(
			startPos.X.Scale, startPos.X.Offset + delta.X,
			startPos.Y.Scale, startPos.Y.Offset + delta.Y
		)
	end

	guiObject.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			dragStart = input.Position
			startPos = guiObject.Position
			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
				end
			end)
		end
	end)

	guiObject.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			if dragging then update(input) end
		end
	end)
end

--===== MAIN PANEL =====--
local frame = Instance.new("Frame")
frame.Name = "Panel"
frame.Position = UDim2.fromOffset(20, 80)
frame.Size = UDim2.fromOffset(300, 380)
frame.BackgroundColor3 = COLOR_FRAME
frame.Visible = false
frame.Active = true
frame.Parent = gui

Instance.new("UICorner", frame).CornerRadius = UDim.new(0, 12)
local frameStroke = Instance.new("UIStroke", frame)
frameStroke.Color = COLOR_ACCENT
frameStroke.Thickness = 2
makeDraggable(frame)

-- Title bar
local title = Instance.new("TextLabel")
title.Size = UDim2.fromOffset(300, 36)
title.BackgroundColor3 = COLOR_TITLE
title.Text = "NPC Head Hitbox Manager"
title.TextColor3 = Color3.fromRGB(220, 240, 255)
title.Font = Enum.Font.GothamBold
title.TextSize = 16
title.Parent = frame
Instance.new("UICorner", title).CornerRadius = UDim.new(0, 12)

-- Size input
local sizeInput = Instance.new("TextBox")
sizeInput.Position = UDim2.fromOffset(20, 50)
sizeInput.Size = UDim2.fromOffset(260, 32)
sizeInput.PlaceholderText = "Hitbox Size (e.g. 4)"
sizeInput.Text = tostring(DEFAULT_HITBOX_SIZE)
sizeInput.BackgroundColor3 = COLOR_INPUT
sizeInput.TextColor3 = COLOR_TEXT
sizeInput.Font = Enum.Font.Gotham
sizeInput.TextSize = 14
sizeInput.ClearTextOnFocus = false
sizeInput.Parent = frame
Instance.new("UICorner", sizeInput).CornerRadius = UDim.new(0, 8)

-- Move Speed input (đã đổi tên)
local speedInput = Instance.new("TextBox")
speedInput.Position = UDim2.fromOffset(20, 90)
speedInput.Size = UDim2.fromOffset(260, 32)
speedInput.PlaceholderText = "Move Speed (e.g. 16)"
speedInput.Text = tostring(DEFAULT_MOVE_SPEED)
speedInput.BackgroundColor3 = COLOR_INPUT
speedInput.TextColor3 = COLOR_TEXT
speedInput.Font = Enum.Font.Gotham
speedInput.TextSize = 14
speedInput.ClearTextOnFocus = false
speedInput.Parent = frame
Instance.new("UICorner", speedInput).CornerRadius = UDim.new(0, 8)

-- Buttons
local autoToggle = createButton(frame, "Auto Hitbox: OFF", UDim2.fromOffset(20, 130), UDim2.fromOffset(260, 32), COLOR_PRIMARY_D)
local autoMeshToggle = createButton(frame, "Auto Mesh All: OFF", UDim2.fromOffset(20, 170), UDim2.fromOffset(260, 32), COLOR_PRIMARY_D)
local removeAllBtn = createButton(frame, "Remove All Hitboxes", UDim2.fromOffset(20, 210), UDim2.fromOffset(260, 32), COLOR_DANGER)
local clearAllMeshBtn = createButton(frame, "Clear All Mesh", UDim2.fromOffset(20, 250), UDim2.fromOffset(260, 32), COLOR_DANGER)

-- Status
local statusLabel = Instance.new("TextLabel")
statusLabel.Position = UDim2.fromOffset(14, 290)
statusLabel.Size = UDim2.fromOffset(272, 24)
statusLabel.BackgroundTransparency = 1
statusLabel.Text = "Processing: 0 NPCs"
statusLabel.TextColor3 = Color3.fromRGB(180, 255, 200)
statusLabel.Font = Enum.Font.Gotham
statusLabel.TextSize = 14
statusLabel.TextXAlignment = Enum.TextXAlignment.Left
statusLabel.Parent = frame

local function flashStatus(ok, msg)
	statusLabel.Text = msg
	TweenService:Create(statusLabel, TweenInfo.new(0.1), {
		TextColor3 = ok and Color3.fromRGB(190, 255, 210) or Color3.fromRGB(255, 200, 200)
	}):Play()
	task.delay(0.5, function()
		TweenService:Create(statusLabel, TweenInfo.new(0.3), {
			TextColor3 = Color3.fromRGB(180, 255, 200)
		}):Play()
	end)
end

--===== FLOATING TOGGLE BUTTON (draggable) =====--
local toggleBtn = createButton(gui, "Show Menu", UDim2.fromOffset(20, 20), UDim2.fromOffset(120, 36), COLOR_PRIMARY)
toggleBtn.ZIndex = 10
makeDraggable(toggleBtn)

--===== IMMEDIATE HIDE / RESTORE LOGIC =====--
local isAnimating = false
local storedVisibility = {}

local function hideFrameContentImmediately()
	storedVisibility = {}
	for _, child in ipairs(frame:GetDescendants()) do
		if child:IsA("GuiObject") and child ~= frame then
			storedVisibility[child] = child.Visible
			child.Visible = false
		end
	end
end

local function restoreFrameContent()
	for child, vis in pairs(storedVisibility) do
		if child and child.Parent then
			pcall(function() child.Visible = vis end)
		end
	end
	storedVisibility = {}
end

-- Open/Close panel with tween (slide + instant-hide content)
local function toggleMenu()
	if isAnimating then return end
	isAnimating = true

	if frame.Visible then
		hideFrameContentImmediately()
		toggleBtn.Text = "Show Menu"

		local tween = TweenService:Create(frame, TweenInfo.new(0.25), {Size = UDim2.fromOffset(300, 0)})
		tween:Play()
		tween.Completed:Wait()

		frame.Visible = false
		isAnimating = false
	else
		frame.Size = UDim2.fromOffset(300, 0)
		frame.Visible = true

		local tween = TweenService:Create(frame, TweenInfo.new(0.25), {Size = UDim2.fromOffset(300, 380)})
		tween:Play()
		tween.Completed:Wait()

		restoreFrameContent()
		toggleBtn.Text = "Hide Menu"
		isAnimating = false
	end
end

toggleBtn.MouseButton1Click:Connect(toggleMenu)

--===== LOGIC (hitbox & esp) =====--
local function updateStatus()
	local count = 0
	for _ in pairs(processedNPCs) do count = count + 1 end
	statusLabel.Text = ("Processing: %d NPCs"):format(count)
end

local function isValidNPC(model)
	if not model or not model:IsA("Model") then return false end
	if model == LocalPlayer.Character then return false end
	if Players:GetPlayerFromCharacter(model) then return false end
	local hum = model:FindFirstChildOfClass("Humanoid")
	local root = model:FindFirstChild("HumanoidRootPart")
	if not hum or not root then return false end
	return true
end

local function addBodyESP(npc)
	if npc:FindFirstChild("NPCBodyESP") then return npc.NPCBodyESP end
	local root = npc:FindFirstChild("HumanoidRootPart")
	if not root then return end

	local box = Instance.new("BoxHandleAdornment")
	box.Name = "NPCBodyESP"
	box.Adornee = root
	box.Size = root.Size + Vector3.new(4, 4, 4)
	box.Color3 = Color3.fromRGB(255, 120, 120)
	box.Transparency = 0.5
	box.ZIndex = 5
	box.AlwaysOnTop = true
	box.Parent = npc
	return box
end

local function removeHeadHitbox(npc)
	if not npc or not processedNPCs[npc] then return end
	local head = npc:FindFirstChild("Head")

	if processedNPCs[npc].connections then
		disconnectList(processedNPCs[npc].connections)
	end

	if head and head:FindFirstChild("OriginalSize") then
		local originalSize = head.OriginalSize.Value
		head.Size = originalSize
		head.OriginalSize:Destroy()

		head.Massless = false
		head.CanCollide = true
		head.Transparency = 0
		head.Material = Enum.Material.Plastic

		local mesh = head:FindFirstChild("Mesh")
		if mesh then
			mesh.MeshType = Enum.MeshType.Head
			mesh.Scale = Vector3.new(1, 1, 1)
		end
	end

	if processedNPCs[npc].esp then
		processedNPCs[npc].esp:Destroy()
	end

	processedNPCs[npc] = nil
	updateStatus()
end

local function applyHeadHitbox(npc, size)
	if not isValidNPC(npc) then return end
	if processedNPCs[npc] then return end
	if respawnWatchers[npc] then
		disconnectList(respawnWatchers[npc])
		respawnWatchers[npc] = nil
	end

	local head = npc:FindFirstChild("Head")
	local root = npc:FindFirstChild("HumanoidRootPart")
	local hum  = npc:FindFirstChildOfClass("Humanoid")

	if not head and root then
		head = Instance.new("Part")
		head.Name = "Head"
		head.Size = Vector3.new(2, 1, 1)
		head.CFrame = root.CFrame * CFrame.new(0, root.Size.Y/2 + 1, 0)
		head.Anchored = false
		head.CanCollide = false
		head.Massless = true
		head.Transparency = 1
		head.Parent = npc

		local weld = Instance.new("WeldConstraint")
		weld.Part0 = root
		weld.Part1 = head
		weld.Parent = head
	end

	if not head then return end
	if hum and hum.Health and hum.Health <= 0 then return end

	-- Force add mesh head (even if already exists)
	local mesh = head:FindFirstChildOfClass("SpecialMesh")
	if not mesh then
		mesh = Instance.new("SpecialMesh")
		mesh.MeshType = Enum.MeshType.Head
		mesh.Scale = Vector3.new(1, 1, 1)
		mesh.Name = "Mesh"
		mesh.Parent = head
	else
		-- Reset existing mesh
		mesh.MeshType = Enum.MeshType.Head
		mesh.Scale = Vector3.new(1, 1, 1)
	end

	if not head:FindFirstChild("OriginalSize") then
		local original = Instance.new("Vector3Value")
		original.Name = "OriginalSize"
		original.Value = head.Size
		original.Parent = head
	end

	-- Apply big head
	head.Massless = true
	head.Size = Vector3.new(size, size, size)
	head.CanCollide = false
	head.Transparency = 0.7
	head.Material = Enum.Material.ForceField

	local npcConns = {}
	table.insert(npcConns, head:GetPropertyChangedSignal("Size"):Connect(function()
		if processedNPCs[npc] then
			local wanted = Vector3.new(size, size, size)
			if head.Size ~= wanted then
				head.Size = wanted
			end
		end
	end))

	if hum then
		table.insert(npcConns, hum.Died:Connect(function()
			removeHeadHitbox(npc)
		end))
	end

	local esp = addBodyESP(npc)
	processedNPCs[npc] = {connections = npcConns, esp = esp}
	updateStatus()
end

local function addMeshToAllNPCs()
	local size = tonumber(sizeInput.Text) or DEFAULT_HITBOX_SIZE
	for _, npc in ipairs(workspace:GetDescendants()) do
		if isValidNPC(npc) then
			applyHeadHitbox(npc, size)
		end
	end
end

local function clearAllMesh()
	for npc, _ in pairs(processedNPCs) do
		local head = npc:FindFirstChild("Head")
		if head then
			local mesh = head:FindFirstChildOfClass("SpecialMesh")
			if mesh then
				mesh:Destroy()
			end
		end
	end
	flashStatus(true, "Cleared all mesh.")
end

local function scanWorkspace()
	local size = tonumber(sizeInput.Text) or DEFAULT_HITBOX_SIZE
	for _, v in ipairs(workspace:GetDescendants()) do
		if isValidNPC(v) then
			applyHeadHitbox(v, size)
		end
	end
end

local function tryApplyModel(model)
	task.delay(0.2, function()
		if isValidNPC(model) then
			local size = tonumber(sizeInput.Text) or DEFAULT_HITBOX_SIZE
			applyHeadHitbox(model, size)
		end
	end)
end

local function clearAll()
	for npc, _ in pairs(processedNPCs) do
		removeHeadHitbox(npc)
	end
	for npc, conns in pairs(respawnWatchers) do
		disconnectList(conns)
		respawnWatchers[npc] = nil
	end
	flashStatus(true, "Cleared all.")
end

-- Hàm điều chỉnh tốc độ di chuyển của nhân vật
local function updatePlayerSpeed()
	local character = LocalPlayer.Character
	if not character then return end
	
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if humanoid then
		humanoid.WalkSpeed = moveSpeed
	end
end

-- Kết nối để theo dõi thay đổi nhân vật
local function startSpeedControl()
	if speedConnection then
		speedConnection:Disconnect()
		speedConnection = nil
	end
	
	-- Cập nhật tốc độ khi nhân vật thay đổi
	speedConnection = LocalPlayer.CharacterAdded:Connect(function(character)
		character:WaitForChild("Humanoid")
		updatePlayerSpeed()
		
		-- Cũng theo dõi khi Humanoid được thêm vào sau
		character.ChildAdded:Connect(function(child)
			if child:IsA("Humanoid") then
				updatePlayerSpeed()
			end
		end)
	end)
	
	-- Cập nhật tốc độ cho nhân vật hiện tại
	updatePlayerSpeed()
end

local function stopSpeedControl()
	if speedConnection then
		speedConnection:Disconnect()
		speedConnection = nil
	end
	
	-- Reset tốc độ về mặc định
	local character = LocalPlayer.Character
	if character then
		local humanoid = character:FindFirstChildOfClass("Humanoid")
		if humanoid then
			humanoid.WalkSpeed = 16 -- Tốc độ mặc định của Roblox
		end
	end
end

-- Auto loop function cho mesh (giữ nguyên)
local function startAutoMeshLoop()
	if speedConnection then
		speedConnection:Disconnect()
		speedConnection = nil
	end
	
	speedConnection = RunService.Heartbeat:Connect(function()
		if autoMeshEnabled then
			addMeshToAllNPCs()
		end
	end)
end

local function stopAutoMeshLoop()
	if speedConnection then
		speedConnection:Disconnect()
		speedConnection = nil
	end
end

--===== BUTTON EVENTS =====--
autoToggle.MouseButton1Click:Connect(function()
	autoHitboxEnabled = not autoHitboxEnabled
	autoToggle.Text = autoHitboxEnabled and "Auto Hitbox: ON" or "Auto Hitbox: OFF"
	autoToggle.BackgroundColor3 = autoHitboxEnabled and COLOR_GOOD or COLOR_PRIMARY_D

	for _, conn in ipairs(connections) do pcall(function() conn:Disconnect() end) end
	table.clear(connections)

	if autoHitboxEnabled then
		flashStatus(true, "Auto ON → Scanning...")
		scanWorkspace()
		table.insert(connections, workspace.DescendantAdded:Connect(function(desc)
			local model = desc:FindFirstAncestorOfClass("Model")
			if model then tryApplyModel(model) end
		end))
		table.insert(connections, workspace.ChildAdded:Connect(function(child)
			if child:IsA("Model") then tryApplyModel(child) end
		end))
	else
		flashStatus(false, "Auto OFF")
	end
end)

autoMeshToggle.MouseButton1Click:Connect(function()
	autoMeshEnabled = not autoMeshEnabled
	autoMeshToggle.Text = autoMeshEnabled and "Auto Mesh All: ON" or "Auto Mesh All: OFF"
	autoMeshToggle.BackgroundColor3 = autoMeshEnabled and COLOR_GOOD or COLOR_PRIMARY_D

	if autoMeshEnabled then
		flashStatus(true, "Auto Mesh ON")
		startAutoMeshLoop()
	else
		flashStatus(false, "Auto Mesh OFF")
		stopAutoMeshLoop()
	end
end)

removeAllBtn.MouseButton1Click:Connect(function()
	clearAll()
end)

clearAllMeshBtn.MouseButton1Click:Connect(function()
	clearAllMesh()
end)

-- Update move speed when input changes
speedInput.FocusLost:Connect(function()
	local newSpeed = tonumber(speedInput.Text) or DEFAULT_MOVE_SPEED
	moveSpeed = math.max(0, math.min(100, newSpeed)) -- Clamp between 0 and 100
	
	-- Cập nhật tốc độ di chuyển ngay lập tức
	updatePlayerSpeed()
	flashStatus(true, "Move speed: " .. moveSpeed)
end)

-- Tự động bật điều khiển tốc độ khi script chạy
startSpeedControl()

--===== PLAYER RELOAD =====--
LocalPlayer.CharacterAdded:Connect(function()
	task.wait(2)
	if autoHitboxEnabled then scanWorkspace() end
	if autoMeshEnabled then addMeshToAllNPCs() end
	-- Cập nhật lại tốc độ khi nhân vật respawn
	updatePlayerSpeed()
end)
