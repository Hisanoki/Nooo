

--===== SERVICES =====--
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")

local LocalPlayer = Players.LocalPlayer

--===== CONFIG =====--
local DEFAULT_HITBOX_SIZE = 4
local MOBILE_FRAME_WIDTH = 280
local MOBILE_PADDING = 15

-- Colors (light blue theme - mobile friendly)
local COLOR_PRIMARY   = Color3.fromRGB(140, 185, 255)
local COLOR_PRIMARY_D = Color3.fromRGB(100, 150, 255)
local COLOR_ACCENT    = Color3.fromRGB(180, 220, 255)
local COLOR_FRAME     = Color3.fromRGB(40, 60, 100)
local COLOR_TITLE     = Color3.fromRGB(30, 50, 90)
local COLOR_INPUT     = Color3.fromRGB(60, 90, 140)
local COLOR_TEXT      = Color3.fromRGB(255, 255, 255)
local COLOR_DANGER    = Color3.fromRGB(200, 80, 80)
local COLOR_GOOD      = Color3.fromRGB(80, 180, 120)
local COLOR_WARN      = Color3.fromRGB(255, 170, 80)

--===== STATE =====--
local processedNPCs = {}     -- [Model] = {connections = {RBXScriptConnection,...}, esp = Instance}
local respawnWatchers = {}   -- [Model] = {RBXScriptConnection,...}
local connections = {}       -- workspace listeners
local autoHitboxEnabled = false
local autoMeshEnabled = false

--===== GUI ROOT =====--
local gui = Instance.new("ScreenGui")
gui.Name = "NPC_Hitbox_GUI_Mobile"
gui.ResetOnSpawn = false
gui.Parent = game.CoreGui

--===== HELPERS =====--
local function disconnectList(list)
	if not list then return end
	for _, c in ipairs(list) do
		pcall(function() c:Disconnect() end)
	end
end

-- Create mobile-friendly button
local function createButton(parent, text, pos, size, baseColor)
	local btn = Instance.new("TextButton")
	btn.AnchorPoint = Vector2.new(0, 0)
	btn.Position = pos
	btn.Size = size or UDim2.fromOffset(MOBILE_FRAME_WIDTH - MOBILE_PADDING * 2, 32)
	btn.BackgroundColor3 = baseColor or COLOR_PRIMARY
	btn.Text = text
	btn.TextColor3 = COLOR_TEXT
	btn.Font = Enum.Font.GothamBold
	btn.TextSize = 14
	btn.AutoButtonColor = false
	btn.Parent = parent

	local corner = Instance.new("UICorner", btn)
	corner.CornerRadius = UDim.new(0, 8)

	local stroke = Instance.new("UIStroke", btn)
	stroke.Color = COLOR_ACCENT
	stroke.Thickness = 1

	-- hover/press effect (mobile touch friendly)
	btn.MouseEnter:Connect(function()
		TweenService:Create(btn, TweenInfo.new(0.15), {
			BackgroundColor3 = baseColor:Lerp(COLOR_ACCENT, 0.25)
		}):Play()
	end)
	btn.MouseLeave:Connect(function()
		TweenService:Create(btn, TweenInfo.new(0.15), {
			BackgroundColor3 = baseColor
		}):Play()
	end)

	-- touch "press" animation
	local origSize = btn.Size
	btn.MouseButton1Click:Connect(function()
		local down = TweenService:Create(btn, TweenInfo.new(0.08), {
			Size = UDim2.new(origSize.X.Scale, math.max(0, origSize.X.Offset - 6), origSize.Y.Scale, math.max(0, origSize.Y.Offset - 4))
		})
		local up = TweenService:Create(btn, TweenInfo.new(0.08), {
			Size = origSize
		})
		down:Play()
		down.Completed:Wait()
		up:Play()
	end)

	return btn
end

-- Mobile-friendly draggable (better for touch)
local function makeDraggable(guiObject)
	local dragging = false
	local dragStart, startPos

	local function update(input)
		local delta = input.Position - dragStart
		guiObject.Position = UDim2.new(
			math.clamp(startPos.X.Scale, 0, 1),
			math.clamp(startPos.X.Offset + delta.X, -10, 300),
			math.clamp(startPos.Y.Scale, 0, 1),
			math.clamp(startPos.Y.Offset + delta.Y, -10, 100)
		)
	end

	guiObject.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			dragStart = input.Position
			startPos = guiObject.Position
			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
				end
			end)
		end
	end)

	guiObject.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.Touch then
			if dragging then update(input) end
		end
	end)
end

--===== MAIN PANEL =====--
local frame = Instance.new("Frame")
frame.Name = "Panel"
frame.Position = UDim2.fromOffset(10, 100)
frame.Size = UDim2.fromOffset(MOBILE_FRAME_WIDTH, 0) -- Start collapsed
frame.BackgroundColor3 = COLOR_FRAME
frame.Visible = false
frame.Active = true
frame.Parent = gui

Instance.new("UICorner", frame).CornerRadius = UDim.new(0, 12)
local frameStroke = Instance.new("UIStroke", frame)
frameStroke.Color = COLOR_ACCENT
frameStroke.Thickness = 2
makeDraggable(frame)

-- Title bar
local title = Instance.new("TextLabel")
title.Size = UDim2.fromOffset(MOBILE_FRAME_WIDTH, 36)
title.BackgroundColor3 = COLOR_TITLE
title.Text = "ðŸŒŒ NPC Hitbox Mobile"
title.TextColor3 = Color3.fromRGB(220, 240, 255)
title.Font = Enum.Font.GothamBold
title.TextSize = 16
title.Parent = frame
Instance.new("UICorner", title).CornerRadius = UDim.new(0, 12)

-- Size input
local sizeInput = Instance.new("TextBox")
sizeInput.Position = UDim2.fromOffset(MOBILE_PADDING, 50)
sizeInput.Size = UDim2.fromOffset(MOBILE_FRAME_WIDTH - MOBILE_PADDING * 2, 32)
sizeInput.PlaceholderText = "Hitbox Size (e.g. 4)"
sizeInput.Text = tostring(DEFAULT_HITBOX_SIZE)
sizeInput.BackgroundColor3 = COLOR_INPUT
sizeInput.TextColor3 = COLOR_TEXT
sizeInput.Font = Enum.Font.Gotham
sizeInput.TextSize = 14
sizeInput.ClearTextOnFocus = false
sizeInput.Parent = frame
Instance.new("UICorner", sizeInput).CornerRadius = UDim.new(0, 8)

-- Buttons (mobile layout)
local indexY = 90
local buttonSpacing = 36

local autoToggle = createButton(frame, "Auto Hitbox: OFF", UDim2.fromOffset(MOBILE_PADDING, indexY), nil, COLOR_PRIMARY_D)
indexY = indexY + buttonSpacing

local autoMeshToggle = createButton(frame, "Auto Add Mesh: OFF", UDim2.fromOffset(MOBILE_PADDING, indexY), nil, COLOR_WARN)
indexY = indexY + buttonSpacing

local removeAllBtn = createButton(frame, "Remove All Hitboxes", UDim2.fromOffset(MOBILE_PADDING, indexY), nil, COLOR_DANGER)
indexY = indexY + buttonSpacing

local clearMeshBtn = createButton(frame, "Clear All Mesh", UDim2.fromOffset(MOBILE_PADDING, indexY), nil, Color3.fromRGB(120, 80, 180))
indexY = indexY + buttonSpacing

-- Status
local statusLabel = Instance.new("TextLabel")
statusLabel.Position = UDim2.fromOffset(MOBILE_PADDING, indexY)
statusLabel.Size = UDim2.fromOffset(MOBILE_FRAME_WIDTH - MOBILE_PADDING * 2, 24)
statusLabel.BackgroundTransparency = 1
statusLabel.Text = "Processing: 0 NPCs"
statusLabel.TextColor3 = Color3.fromRGB(180, 255, 200)
statusLabel.Font = Enum.Font.Gotham
statusLabel.TextSize = 13
statusLabel.TextXAlignment = Enum.TextXAlignment.Left
statusLabel.Parent = frame

local function flashStatus(ok, msg)
	statusLabel.Text = msg
	TweenService:Create(statusLabel, TweenInfo.new(0.1), {
		TextColor3 = ok and Color3.fromRGB(190, 255, 210) or Color3.fromRGB(255, 200, 200)
	}):Play()
	task.delay(0.5, function()
		TweenService:Create(statusLabel, TweenInfo.new(0.3), {
			TextColor3 = Color3.fromRGB(180, 255, 200)
		}):Play()
	end)
end

--===== MOBILE TOGGLE BUTTON (draggable) =====--
local toggleBtn = createButton(gui, "Menu", UDim2.fromOffset(10, 10), UDim2.fromOffset(100, 36), COLOR_PRIMARY)
toggleBtn.ZIndex = 10
makeDraggable(toggleBtn)

--===== ANIMATION SYSTEM =====--
local isAnimating = false
local storedVisibility = {}

local function hideFrameContentImmediately()
	storedVisibility = {}
	for _, child in ipairs(frame:GetDescendants()) do
		if child:IsA("GuiObject") and child ~= frame then
			storedVisibility[child] = child.Visible
			child.Visible = false
		end
	end
end

local function restoreFrameContent()
	for child, vis in pairs(storedVisibility) do
		if child and child.Parent then
			pcall(function() child.Visible = vis end)
		end
	end
	storedVisibility = {}
end

local function toggleMenu()
	if isAnimating then return end
	isAnimating = true

	if frame.Visible then
		hideFrameContentImmediately()
		toggleBtn.Text = "Menu"

		local tween = TweenService:Create(frame, TweenInfo.new(0.25), {Size = UDim2.fromOffset(MOBILE_FRAME_WIDTH, 0)})
		tween:Play()
		tween.Completed:Wait()
		frame.Visible = false
		isAnimating = false
	else
		frame.Size = UDim2.fromOffset(MOBILE_FRAME_WIDTH, 0)
		frame.Visible = true

		local tween = TweenService:Create(frame, TweenInfo.new(0.25), {Size = UDim2.fromOffset(MOBILE_FRAME_WIDTH, indexY + 30)})
		tween:Play()
		tween.Completed:Wait()

		restoreFrameContent()
		toggleBtn.Text = "Close"
		isAnimating = false
	end
end

toggleBtn.MouseButton1Click:Connect(toggleMenu)

--===== CORE LOGIC =====--
local function updateStatus()
	local count = 0
	for _ in pairs(processedNPCs) do count = count + 1 end
	statusLabel.Text = ("Processing: %d NPCs"):format(count)
end

local function isValidNPC(model)
	if not model or not model:IsA("Model") then return false end
	if model == LocalPlayer.Character then return false end
	if Players:GetPlayerFromCharacter(model) then return false end
	local hum = model:FindFirstChildOfClass("Humanoid")
	local root = model:FindFirstChild("HumanoidRootPart")
	if not hum or not root then return false end
	return true
end

-- Add body ESP
local function addBodyESP(npc)
	if npc:FindFirstChild("NPCBodyESP") then return npc.NPCBodyESP end
	local root = npc:FindFirstChild("HumanoidRootPart")
	if not root then return end

	local box = Instance.new("BoxHandleAdornment")
	box.Name = "NPCBodyESP"
	box.Adornee = root
	box.Size = root.Size + Vector3.new(4, 4, 4)
	box.Color3 = Color3.fromRGB(255, 120, 120)
	box.Transparency = 0.5
	box.ZIndex = 5
	box.AlwaysOnTop = true
	box.Parent = npc
	return box
end

-- Remove head hitbox
local function removeHeadHitbox(npc)
	if not npc or not processedNPCs[npc] then return end
	local head = npc:FindFirstChild("Head")

	if processedNPCs[npc].connections then
		disconnectList(processedNPCs[npc].connections)
	end

	if head and head:FindFirstChild("OriginalSize") then
		local originalSize = head.OriginalSize.Value
		head.Size = originalSize
		head.OriginalSize:Destroy()

		head.Massless = false
		head.CanCollide = true
		head.Transparency = 0
		head.Material = Enum.Material.Plastic

		local mesh = head:FindFirstChild("Mesh")
		if mesh then
			mesh.MeshType = Enum.MeshType.Head
			mesh.Scale = Vector3.new(1, 1, 1)
		end
	end

	if processedNPCs[npc].esp then
		processedNPCs[npc].esp:Destroy()
	end

	processedNPCs[npc] = nil
	updateStatus()
end

-- Apply head hitbox
local function applyHeadHitbox(npc, size)
	if not isValidNPC(npc) then return end
	if processedNPCs[npc] then return end

	local head = npc:FindFirstChild("Head")
	local root = npc:FindFirstChild("HumanoidRootPart")
	local hum = npc:FindFirstChildOfClass("Humanoid")

	if not head and root then
		head = Instance.new("Part")
		head.Name = "Head"
		head.Size = Vector3.new(2, 1, 1)
		head.CFrame = root.CFrame * CFrame.new(0, root.Size.Y/2 + 1, 0)
		head.Anchored = false
		head.CanCollide = false
		head.Massless = true
		head.Transparency = 1
		head.Parent = npc

		local weld = Instance.new("WeldConstraint")
		weld.Part0 = root
		weld.Part1 = head
		weld.Parent = head
	end

	if not head then return end
	if hum and hum.Health and hum.Health <= 0 then return end

	if not head:FindFirstChild("Mesh") then
		local mesh = Instance.new("SpecialMesh")
		mesh.MeshType = Enum.MeshType.Head
		mesh.Scale = Vector3.new(1, 1, 1)
		mesh.Name = "Mesh"
		mesh.Parent = head
	end

	if not head:FindFirstChild("OriginalSize") then
		local original = Instance.new("Vector3Value")
		original.Name = "OriginalSize"
		original.Value = head.Size
		original.Parent = head
	end

	head.Massless = true
	head.Size = Vector3.new(size, size, size)
	head.CanCollide = false
	head.Transparency = 0.7
	head.Material = Enum.Material.ForceField

	local npcConns = {}
	table.insert(npcConns, head:GetPropertyChangedSignal("Size"):Connect(function()
		if processedNPCs[npc] then
			local wanted = Vector3.new(size, size, size)
			if head.Size ~= wanted then
				head.Size = wanted
			end
		end
	end))

	if hum then
		table.insert(npcConns, hum.Died:Connect(function()
			removeHeadHitbox(npc)
		end))
	end

	local esp = addBodyESP(npc)
	processedNPCs[npc] = {connections = npcConns, esp = esp}
	updateStatus()
end

-- Add/Update Mesh Head for any NPC (even if exists)
local function addOrUpdateMeshHead(npc)
	if not isValidNPC(npc) then return end
	local head = npc:FindFirstChild("Head")
	if not head then return end

	local mesh = head:FindFirstChild("SpecialMesh") or head:FindFirstChildWhichIsA("Mesh")
	if not mesh then
		mesh = Instance.new("SpecialMesh")
		mesh.MeshType = Enum.MeshType.Head
		mesh.Scale = Vector3.new(1, 1, 1)
		mesh.Parent = head
	else
		mesh.MeshType = Enum.MeshType.Head
		mesh.Scale = Vector3.new(1, 1, 1)
	end
end

-- Scan all NPCs in workspace (deep search)
local function scanWorkspace()
	local size = tonumber(sizeInput.Text) or DEFAULT_HITBOX_SIZE
	for _, v in ipairs(workspace:GetDescendants()) do
		if isValidNPC(v) then
			applyHeadHitbox(v, size)
		end
	end
end

-- Auto add mesh to all NPCs (recursive, non-laggy)
local function addMeshToAllNPCs()
	local size = tonumber(sizeInput.Text) or DEFAULT_HITBOX_SIZE
	local processed = 0

	for _, v in ipairs(workspace:GetDescendants()) do
		if isValidNPC(v) then
			addOrUpdateMeshHead(v)
			applyHeadHitbox(v, size)
			processed = processed + 1

			-- Prevent lag: yield every 10 NPCs
			if processed % 10 == 0 then
				task.wait()
			end
		end
	end

	flashStatus(true, "Mesh added to " .. processed .. " NPCs")
end

-- Clear all mesh heads
local function clearAllMesh()
	local cleared = 0
	for _, v in ipairs(workspace:GetDescendants()) do
		if isValidNPC(v) then
			local head = v:FindFirstChild("Head")
			if head then
				local mesh = head:FindFirstChild("Mesh") or head:FindFirstChild("SpecialMesh")
				if mesh and mesh.Name == "Mesh" then
					mesh:Destroy()
					cleared = cleared + 1
				end
			end
		end
	end
	flashStatus(true, "Cleared " .. cleared .. " meshes")
end

local function tryApplyModel(model)
	task.delay(0.2, function()
		if isValidNPC(model) then
			local size = tonumber(sizeInput.Text) or DEFAULT_HITBOX_SIZE
			applyHeadHitbox(model, size)
		end
	end)
end

local function clearAll()
	for npc, _ in pairs(processedNPCs) do
		removeHeadHitbox(npc)
	end
	for npc, conns in pairs(respawnWatchers) do
		disconnectList(conns)
		respawnWatchers[npc] = nil
	end
	flashStatus(true, "Cleared all.")
end

--===== BUTTON EVENTS =====--
autoToggle.MouseButton1Click:Connect(function()
	autoHitboxEnabled = not autoHitboxEnabled
	autoToggle.Text = autoHitboxEnabled and "Auto Hitbox: ON" or "Auto Hitbox: OFF"
	autoToggle.BackgroundColor3 = autoHitboxEnabled and COLOR_GOOD or COLOR_PRIMARY_D

	for _, conn in ipairs(connections) do
		pcall(function() conn:Disconnect() end)
	end
	table.clear(connections)

	if autoHitboxEnabled then
		flashStatus(true, "Auto ON â†’ Scanning...")
		scanWorkspace()
		table.insert(connections, workspace.DescendantAdded:Connect(function(desc)
			local model = desc:FindFirstAncestorOfClass("Model")
			if model then tryApplyModel(model) end
		end))
		table.insert(connections, workspace.ChildAdded:Connect(function(child)
			if child:IsA("Model") then tryApplyModel(child) end
		end))
	else
		flashStatus(false, "Auto OFF")
	end
end)

autoMeshToggle.MouseButton1Click:Connect(function()
	autoMeshEnabled = not autoMeshEnabled
	autoMeshToggle.Text = autoMeshEnabled and "Auto Add Mesh: ON" or "Auto Add Mesh: OFF"
	autoMeshToggle.BackgroundColor3 = autoMeshEnabled and COLOR_GOOD or COLOR_WARN

	if autoMeshEnabled then
		flashStatus(true, "Auto Mesh ON â†’ Adding to all...")
		task.spawn(addMeshToAllNPCs)
	else
		flashStatus(false, "Auto Mesh OFF")
	end
end)

removeAllBtn.MouseButton1Click:Connect(function()
	clearAll()
end)

clearMeshBtn.MouseButton1Click:Connect(function()
	clearAllMesh()
end)

--===== PLAYER RELOAD =====--
LocalPlayer.CharacterAdded:Connect(function()
	task.wait(2)
	if autoHitboxEnabled then
		scanWorkspace()
	end
	if autoMeshEnabled then
		task.spawn(addMeshToAllNPCs)
	end
end)
