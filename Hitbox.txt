-- Combined Head Hitbox & Invisibility GUI (Mobile Tab Version)
-- Rewritten to reliably apply hitboxes/ESP to all players (except local),
-- fully remove all hitbox/ESP on death, and reapply on respawn.

-- SERVICES
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer

-- CONFIG
local DEFAULT_HITBOX_SIZE = 4
local ESP_COLOR = Color3.fromRGB(255, 150, 150)
local ESP_TRANSPARENCY = 0.7
local TEXT_ESP_COLOR = Color3.fromRGB(255, 255, 255)

local INVIS_CONFIG = {
	TOGGLE_KEY = Enum.KeyCode.X,
	SOUND_ID = "rbxassetid://942127495",
	INVISIBILITY_POSITION = Vector3.new(-25.95, 84, 3537.55),
	NOTIFICATION_DURATION = 3,
	BACKGROUND_COLOR = Color3.fromRGB(25, 25, 25),
	PRIMARY_COLOR = Color3.fromRGB(0, 170, 255),
	SUCCESS_COLOR = Color3.fromRGB(46, 204, 113),
	TEXT_COLOR = Color3.fromRGB(255, 255, 255),
}

-- STATE
local autoHitboxEnabled = false
local nameESPEnabled = false
local boxESPEnabled = false
local espNameAllState = false

-- Data store per player to keep references and connections for clean-up
-- Keys: Player
-- Values: {
--   charConn = RBXScriptConnection (CharacterAdded),
--   humanoidConn = RBXScriptConnection (Humanoid.Died),
--   ancestryConn = RBXScriptConnection (Character.AncestryChanged),
--   nameESPUpdate = RBXScriptConnection (Heartbeat update for distance),
--   applied = boolean,
--   lastSize = number,
--   meshBackup = Instance (or nil)
-- }
local playerData = {}

-- UI and invisibility state
local isInvisible = false
local invisButton
local invisSound

-- Helper utilities
local function tableCount(t)
	local count = 0
	for _ in pairs(t) do count = count + 1 end
	return count
end

local function getTeamColor(player)
	if player and player.Team and player.Team.TeamColor then
		return player.Team.TeamColor.Color
	end
	return ESP_COLOR
end

local function createNotification(title, text)
	pcall(function()
		StarterGui:SetCore("SendNotification", {
			Title = title,
			Text = text,
			Duration = INVIS_CONFIG.NOTIFICATION_DURATION,
		})
	end)
end

local function setCharacterTransparency(character, transparency)
	if not character then return end
	for _, descendant in ipairs(character:GetDescendants()) do
		if descendant:IsA("BasePart") or descendant:IsA("Decal") then
			-- Avoid changing important UI parts owned by tools if any
			pcall(function() descendant.Transparency = transparency end)
		end
	end
end

local function getHumanoidRootPart()
	local character = LocalPlayer.Character
	if not character then return nil end
	return character:FindFirstChild("HumanoidRootPart")
end

local function playInvisSound()
	if invisSound then
		pcall(function() invisSound:Play() end)
	end
end

-- Invisibility Toggle
local function toggleInvisibility()
	if not LocalPlayer.Character then
		warn("Character not found")
		return
	end
	isInvisible = not isInvisible
	playInvisSound()
	if isInvisible then
		local humanoidRootPart = getHumanoidRootPart()
		if not humanoidRootPart then
			warn("HumanoidRootPart not found")
			isInvisible = false
			return
		end
		local savedCFrame = humanoidRootPart.CFrame

		-- Move to invisibility position then spawn invisible seat and weld to HRP
		LocalPlayer.Character:MoveTo(INVIS_CONFIG.INVISIBILITY_POSITION)
		task.wait(0.15)

		local seat = Instance.new("Seat")
		seat.Name = "invischair"
		seat.Anchored = false
		seat.CanCollide = false
		seat.Transparency = 1
		seat.Size = Vector3.new(2, 0.5, 2)
		seat.CFrame = CFrame.new(INVIS_CONFIG.INVISIBILITY_POSITION)
		seat.Parent = workspace

		local weld = Instance.new("Weld")
		weld.Part0 = seat
		weld.Part1 = humanoidRootPart
		weld.Parent = seat

		task.wait()
		seat.CFrame = savedCFrame

		setCharacterTransparency(LocalPlayer.Character, 0.5)
		if invisButton then
			invisButton.BackgroundColor3 = INVIS_CONFIG.SUCCESS_COLOR
			invisButton.Text = "VISIBLE"
		end
		createNotification("Invisibility ON", "You are now invisible")
	else
		local invisChair = workspace:FindFirstChild("invischair")
		if invisChair then
			pcall(function() invisChair:Destroy() end)
		end
		if LocalPlayer.Character then
			setCharacterTransparency(LocalPlayer.Character, 0)
		end
		if invisButton then
			invisButton.BackgroundColor3 = INVIS_CONFIG.PRIMARY_COLOR
			invisButton.Text = "INVISIBLE"
		end
		createNotification("Invisibility OFF", "You are now visible")
	end
end

-- Clean removal helpers: remove all ESP/hitbox artifacts for a player's current character
local function cleanUpCharacterForPlayer(player)
	if not player then return end
	local pdata = playerData[player]
	local character = player.Character
	-- Disconnect any running update loops
	if pdata and pdata.nameESPUpdate then
		pcall(function() pdata.nameESPUpdate:Disconnect() end)
		pdata.nameESPUpdate = nil
	end
	-- Remove BillboardGui named "NameESP"
	if character then
		local head = character:FindFirstChild("Head")
		if head then
			for _, child in ipairs(head:GetChildren()) do
				if child.Name == "NameESP" and child:IsA("BillboardGui") then
					pcall(function() child:Destroy() end)
				elseif child.Name == "BoxCharmESP" then
					pcall(function() child:Destroy() end)
				end
			end
			-- Restore original head state if we stored OriginalSize
			local original = head:FindFirstChild("OriginalSize")
			if original and original:IsA("Vector3Value") then
				pcall(function()
					head.Size = original.Value
					original:Destroy()
				end)
			end
			-- Restore mesh if we backed it up
			if pdata and pdata.meshBackup and pdata.meshBackup:IsA("Mesh") then
				pcall(function()
					if not head:FindFirstChild("Mesh") then
						pdata.meshBackup.Parent = head
					end
				end)
				pdata.meshBackup = nil
			end
			-- Restore other part properties safely
			pcall(function()
				head.Transparency = 0
				head.CanCollide = true
				head.Material = Enum.Material.Plastic
				head.Massless = false
			end)
		end
	end

	-- Mark as not applied
	if pdata then
		pdata.applied = false
		pdata.lastSize = nil
	end
end

-- Add BoxHandleAdornment to a character's head (Box ESP)
local function addBoxESPToCharacter(character, color, size)
	if not character then return end
	local head = character:FindFirstChild("Head")
	if not head or not head:IsA("BasePart") then return end
	-- Avoid duplicates
	local existing = head:FindFirstChild("BoxCharmESP")
	if existing and existing:IsA("BoxHandleAdornment") then
		existing.Size = Vector3.new(size or DEFAULT_HITBOX_SIZE, size or DEFAULT_HITBOX_SIZE, size or DEFAULT_HITBOX_SIZE)
		existing.Color3 = color or ESP_COLOR
		return existing
	end
	local box = Instance.new("BoxHandleAdornment")
	box.Name = "BoxCharmESP"
	box.Adornee = head
	box.Size = Vector3.new(size or DEFAULT_HITBOX_SIZE, size or DEFAULT_HITBOX_SIZE, size or DEFAULT_HITBOX_SIZE)
	box.Color3 = color or ESP_COLOR
	box.Transparency = ESP_TRANSPARENCY
	box.ZIndex = 10
	box.AlwaysOnTop = true
	box.Parent = head
	return box
end

-- Create Name ESP (BillboardGui) and start updating distance + color on Heartbeat
local function createNameESPForPlayer(player)
	if not player or player == LocalPlayer then return end
	local character = player.Character
	if not character then return end
	local head = character:FindFirstChild("Head")
	if not head then return end

	-- Remove existing if present
	local existing = head:FindFirstChild("NameESP")
	if existing and existing:IsA("BillboardGui") then
		pcall(function() existing:Destroy() end)
	end

	local billboard = Instance.new("BillboardGui")
	billboard.Name = "NameESP"
	billboard.Adornee = head
	billboard.Size = UDim2.new(0, 200, 0, 50)
	billboard.StudsOffset = Vector3.new(0, 2.5, 0)
	billboard.AlwaysOnTop = true
	billboard.MaxDistance = 1000
	billboard.Parent = head

	local nameLabel = Instance.new("TextLabel")
	nameLabel.Size = UDim2.new(1, 0, 0.5, 0)
	nameLabel.Position = UDim2.new(0, 0, 0, 0)
	nameLabel.BackgroundTransparency = 1
	nameLabel.Text = player.Name
	nameLabel.TextColor3 = getTeamColor(player)
	nameLabel.TextStrokeTransparency = 0
	nameLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
	nameLabel.Font = Enum.Font.GothamBold
	nameLabel.TextSize = 14
	nameLabel.Parent = billboard

	local distanceLabel = Instance.new("TextLabel")
	distanceLabel.Size = UDim2.new(1, 0, 0.5, 0)
	distanceLabel.Position = UDim2.new(0, 0, 0.5, 0)
	distanceLabel.BackgroundTransparency = 1
	distanceLabel.Text = "0m"
	distanceLabel.TextColor3 = TEXT_ESP_COLOR
	distanceLabel.TextStrokeTransparency = 0
	distanceLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
	distanceLabel.Font = Enum.Font.Gotham
	distanceLabel.TextSize = 12
	distanceLabel.Parent = billboard

	-- Heartbeat update: store connection into playerData so we can disconnect later
	playerData[player] = playerData[player] or {}
	if playerData[player].nameESPUpdate then
		pcall(function() playerData[player].nameESPUpdate:Disconnect() end)
		playerData[player].nameESPUpdate = nil
	end

	playerData[player].nameESPUpdate = RunService.Heartbeat:Connect(function()
		-- ensure everything still exists
		if not billboard.Parent or not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("Head") then
			if playerData[player] and playerData[player].nameESPUpdate then
				pcall(function() playerData[player].nameESPUpdate:Disconnect() end)
				playerData[player].nameESPUpdate = nil
			end
			return
		end
		if head and head:IsDescendantOf(game) and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Head") then
			local localHead = LocalPlayer.Character.Head
			local success, distance = pcall(function()
				return (head.Position - localHead.Position).Magnitude
			end)
			if success and distance then
				distanceLabel.Text = string.format("%.1fm", distance)
			else
				distanceLabel.Text = "0m"
			end
			-- keep team color up to date
			nameLabel.TextColor3 = getTeamColor(player)
		end
	end)
end

-- Apply Head Hitbox to player's character safely
local function applyHeadHitboxToPlayer(player, size)
	if not player or player == LocalPlayer then return end
	local character = player.Character
	if not character then return end
	local head = character:FindFirstChild("Head")
	if not head or not head:IsA("BasePart") then return end

	playerData[player] = playerData[player] or {}
	local pdata = playerData[player]

	-- If already applied and size unchanged, skip
	if pdata.applied and pdata.lastSize == size then
		return
	end

	-- Backup original size
	local original = head:FindFirstChild("OriginalSize")
	if not original then
		local originalValue = Instance.new("Vector3Value")
		originalValue.Name = "OriginalSize"
		originalValue.Value = head.Size
		originalValue.Parent = head
	end

	-- Backup mesh if present (so we can restore later)
	local mesh = head:FindFirstChildOfClass("SpecialMesh") or head:FindFirstChild("Mesh")
	if mesh and mesh.Parent == head then
		pdata.meshBackup = mesh:Clone()
		pcall(function() mesh:Destroy() end)
	end

	-- Apply hitbox modifications
	pcall(function()
		head.Massless = true
		head.Size = Vector3.new(size, size, size)
		head.CanCollide = false
		head.Transparency = 0.5
		head.Material = Enum.Material.ForceField
	end)

	-- Ensure we clean up on death or character removal
	-- Disconnect previous connections if any to avoid leaks
	if pdata.humanoidConn then
		pcall(function() pdata.humanoidConn:Disconnect() end)
		pdata.humanoidConn = nil
	end
	if pdata.ancestryConn then
		pcall(function() pdata.ancestryConn:Disconnect() end)
		pdata.ancestryConn = nil
	end

	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if humanoid then
		pdata.humanoidConn = humanoid.Died:Connect(function()
			-- On death remove everything immediately
			cleanUpCharacterForPlayer(player)
		end)
	end
	-- If character is removed from workspace, ensure cleanup
	pdata.ancestryConn = character.AncestryChanged:Connect(function(_, parent)
		if not parent then
			cleanUpCharacterForPlayer(player)
		end
	end)

	pdata.applied = true
	pdata.lastSize = size
end

-- Remove all hitbox/ESP for a player (used when player dies or leaves)
local function removeAllForPlayer(player)
	if not player then return end
	-- cleanup character artifacts
	cleanUpCharacterForPlayer(player)

	-- disconnect connections stored in playerData
	local pdata = playerData[player]
	if pdata then
		if pdata.humanoidConn then
			pcall(function() pdata.humanoidConn:Disconnect() end)
			pdata.humanoidConn = nil
		end
		if pdata.charConn then
			pcall(function() pdata.charConn:Disconnect() end)
			pdata.charConn = nil
		end
		if pdata.ancestryConn then
			pcall(function() pdata.ancestryConn:Disconnect() end)
			pdata.ancestryConn = nil
		end
		if pdata.nameESPUpdate then
			pcall(function() pdata.nameESPUpdate:Disconnect() end)
			pdata.nameESPUpdate = nil
		end
		-- clear mesh backup
		pdata.meshBackup = nil
		pdata.applied = false
		pdata.lastSize = nil
	end
	playerData[player] = nil
end

-- Apply features to player when their character appears (and reapply automatically on respawn)
local function onCharacterForPlayer(player, character)
	if not player or not character then return end
	-- wait a short moment for parts to exist
	task.wait(0.25)

	-- Reapply head hitbox if auto enabled
	if autoHitboxEnabled then
		applyHeadHitboxToPlayer(player, tonumber(sizeInput.Text) or DEFAULT_HITBOX_SIZE)
	end

	-- Reapply box ESP if enabled
	if boxESPEnabled then
		local color = getTeamColor(player)
		local size = tonumber(sizeInput.Text) or DEFAULT_HITBOX_SIZE
		addBoxESPToCharacter(character, color, size)
	end

	-- Reapply name ESP if either nameESPEnabled for selected or espNameAllState on
	if (nameESPEnabled and selectedPlayers[player]) or espNameAllState then
		createNameESPForPlayer(player)
	end

	-- If team changes, update colors of ESPs
	if player then
		player:GetPropertyChangedSignal("Team"):Connect(function()
			if character and character.Parent then
				-- Update box color
				if boxESPEnabled then
					addBoxESPToCharacter(character, getTeamColor(player), tonumber(sizeInput.Text) or DEFAULT_HITBOX_SIZE)
				end
				-- Update nameESP color
				local head = character:FindFirstChild("Head")
				if head then
					local billboard = head:FindFirstChild("NameESP")
					if billboard and billboard:FindFirstChildOfClass("TextLabel") then
						billboard:FindFirstChildOfClass("TextLabel").TextColor3 = getTeamColor(player)
					end
				end
			end
		end)
	end
end

-- Top-level player handling: setup CharacterAdded listener to always reapply on respawn
local function handlePlayer(player)
	if not player or player == LocalPlayer then return end
	-- ensure previous data cleaned
	removeAllForPlayer(player)

	playerData[player] = playerData[player] or {}

	-- CharacterAdded handler
	playerData[player].charConn = player.CharacterAdded:Connect(function(character)
		onCharacterForPlayer(player, character)
	end)

	-- If player already has character, call handler now
	if player.Character then
		onCharacterForPlayer(player, player.Character)
	end

	-- When player leaves the game, clean everything
	player.AncestryChanged:Connect(function(_, parent)
		if not parent then
			removeAllForPlayer(player)
		end
	end)
end

-- UI CREATION (Mobile size) and existing UI helper functions
local function createTransparentButton(text, color, parent)
	local btn = Instance.new("TextButton")
	btn.Size = UDim2.new(1, 0, 0, 32)
	btn.Text = text
	btn.BackgroundColor3 = color
	btn.BackgroundTransparency = 0.7
	btn.TextColor3 = Color3.new(1, 1, 1)
	btn.Font = Enum.Font.Gotham
	btn.TextSize = 14
	btn.BorderSizePixel = 0
	btn.Parent = parent
	local btnCorner = Instance.new("UICorner")
	btnCorner.CornerRadius = UDim.new(0, 4)
	btnCorner.Parent = btn
	return btn
end

local function createTransparentInput(placeholder, text, parent)
	local input = Instance.new("TextBox")
	input.Size = UDim2.new(1, 0, 0, 32)
	input.PlaceholderText = placeholder
	input.Text = text
	input.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
	input.BackgroundTransparency = 0.7
	input.TextColor3 = Color3.new(1, 1, 1)
	input.Font = Enum.Font.Gotham
	input.TextSize = 14
	input.BorderSizePixel = 0
	input.Parent = parent
	local inputCorner = Instance.new("UICorner")
	inputCorner.CornerRadius = UDim.new(0, 4)
	inputCorner.Parent = input
	return input
end

local function createTransparentLabel(text, parent)
	local label = Instance.new("TextLabel")
	label.Size = UDim2.new(1, 0, 0, 22)
	label.BackgroundTransparency = 1
	label.Text = text
	label.TextColor3 = Color3.fromRGB(200, 200, 200)
	label.Font = Enum.Font.Gotham
	label.TextSize = 12
	label.TextXAlignment = Enum.TextXAlignment.Left
	label.Parent = parent
	return label
end

-- Build GUI (kept similar to original, but event wiring uses robust functions above)
local gui = Instance.new("ScreenGui")
gui.Name = "Mobile_ESP_GUI"
gui.ResetOnSpawn = false
gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
gui.Parent = LocalPlayer:WaitForChild("PlayerGui")

local mainContainer = Instance.new("Frame")
mainContainer.Size = UDim2.new(0, 220, 0, 36)
mainContainer.Position = UDim2.new(0.5, -110, 0, 10)
mainContainer.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
mainContainer.BackgroundTransparency = 0.7
mainContainer.BorderSizePixel = 0
mainContainer.Active = true
mainContainer.Draggable = true
mainContainer.Parent = gui
local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0, 8)
corner.Parent = mainContainer

local toggleUIButton = Instance.new("TextButton")
toggleUIButton.Size = UDim2.new(0, 110, 0, 28)
toggleUIButton.Position = UDim2.new(0.5, -55, 0.5, -14)
toggleUIButton.Text = "☰ Open Menu"
toggleUIButton.TextColor3 = Color3.fromRGB(255, 255, 255)
toggleUIButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
toggleUIButton.BackgroundTransparency = 0.7
toggleUIButton.BorderSizePixel = 0
toggleUIButton.Font = Enum.Font.Gotham
toggleUIButton.TextSize = 14
toggleUIButton.Parent = mainContainer
local buttonCorner = Instance.new("UICorner")
buttonCorner.CornerRadius = UDim.new(0, 6)
buttonCorner.Parent = toggleUIButton

local mainFrame = Instance.new("Frame")
mainFrame.Size = UDim2.new(0, 220, 0, 360)
mainFrame.Position = UDim2.new(0.5, -110, 0.5, -180)
mainFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
mainFrame.BackgroundTransparency = 0.7
mainFrame.BorderSizePixel = 0
mainFrame.Visible = false
mainFrame.Active = true
mainFrame.Draggable = true
mainFrame.Parent = gui
local mainCorner = Instance.new("UICorner")
mainCorner.CornerRadius = UDim.new(0, 8)
mainCorner.Parent = mainFrame

-- Tab Bar
local tabBar = Instance.new("Frame")
tabBar.Size = UDim2.new(1, 0, 0, 32)
tabBar.Position = UDim2.new(0, 0, 0, 0)
tabBar.BackgroundTransparency = 1
tabBar.Parent = mainFrame

local tab1Btn = Instance.new("TextButton")
tab1Btn.Size = UDim2.new(0.5, -2, 1, 0)
tab1Btn.Position = UDim2.new(0, 0, 0, 0)
tab1Btn.Text = "HeadHitbox"
tab1Btn.TextColor3 = Color3.fromRGB(255, 255, 255)
tab1Btn.BackgroundColor3 = Color3.fromRGB(220, 60, 60)
tab1Btn.BackgroundTransparency = 0.2
tab1Btn.Font = Enum.Font.GothamBold
tab1Btn.TextSize = 14
tab1Btn.BorderSizePixel = 0
tab1Btn.Parent = tabBar
local tab1Corner = Instance.new("UICorner")
tab1Corner.CornerRadius = UDim.new(0, 6)
tab1Corner.Parent = tab1Btn

local tab2Btn = Instance.new("TextButton")
tab2Btn.Size = UDim2.new(0.5, -2, 1, 0)
tab2Btn.Position = UDim2.new(0.5, 2, 0, 0)
tab2Btn.Text = "Other"
tab2Btn.TextColor3 = Color3.fromRGB(255, 255, 255)
tab2Btn.BackgroundColor3 = Color3.fromRGB(60, 120, 220)
tab2Btn.BackgroundTransparency = 0.2
tab2Btn.Font = Enum.Font.GothamBold
tab2Btn.TextSize = 14
tab2Btn.BorderSizePixel = 0
tab2Btn.Parent = tabBar
local tab2Corner = Instance.new("UICorner")
tab2Corner.CornerRadius = UDim.new(0, 6)
tab2Corner.Parent = tab2Btn

-- Tab Panels
local leftPanel = Instance.new("Frame")
leftPanel.Size = UDim2.new(1, -12, 1, -44)
leftPanel.Position = UDim2.new(0, 6, 0, 38)
leftPanel.BackgroundTransparency = 1
leftPanel.BorderSizePixel = 0
leftPanel.Visible = true
leftPanel.Parent = mainFrame

local rightPanel = Instance.new("ScrollingFrame")
rightPanel.Size = UDim2.new(1, -12, 1, -44)
rightPanel.Position = UDim2.new(0, 6, 0, 38)
rightPanel.BackgroundTransparency = 1
rightPanel.BorderSizePixel = 0
rightPanel.ScrollBarThickness = 4
rightPanel.CanvasSize = UDim2.new(0, 0, 0, 0)
rightPanel.Visible = false
rightPanel.Parent = mainFrame

local leftLayout = Instance.new("UIListLayout")
leftLayout.Parent = leftPanel
leftLayout.SortOrder = Enum.SortOrder.LayoutOrder
leftLayout.Padding = UDim.new(0, 4)

local rightLayout = Instance.new("UIListLayout")
rightLayout.Parent = rightPanel
rightLayout.SortOrder = Enum.SortOrder.LayoutOrder
rightLayout.Padding = UDim.new(0, 4)

-- HeadHitbox Tab (leftPanel)
local leftTitle = createTransparentLabel("Head hitbox", leftPanel)
leftTitle.TextColor3 = Color3.fromRGB(255, 150, 150)
leftTitle.Font = Enum.Font.GothamBold
leftTitle.TextSize = 14

local sizeInput = createTransparentInput("Size (e.g. 4)", tostring(DEFAULT_HITBOX_SIZE), leftPanel)
local autoToggle = createTransparentButton("Auto Hitbox: OFF", Color3.fromRGB(180, 50, 50), leftPanel)
local removeAllBtn = createTransparentButton("Remove All Hitboxes", Color3.fromRGB(180, 50, 50), leftPanel)
local statusLabel = createTransparentLabel("Processing: 0 Players", leftPanel)
local loopspeedLabel = createTransparentLabel("Loopspeed", leftPanel)
local loopspeedInput = createTransparentInput("Speed (e.g. 16)", "16", leftPanel)
local loopspeedToggle = createTransparentButton("Loopspeed: OFF", Color3.fromRGB(80, 80, 200), leftPanel)
invisButton = createTransparentButton("INVISIBLE", INVIS_CONFIG.PRIMARY_COLOR, leftPanel)

-- Sound for invisibility toggle
invisSound = Instance.new("Sound")
invisSound.Name = "ToggleSound"
invisSound.SoundId = INVIS_CONFIG.SOUND_ID
invisSound.Volume = 0.5
invisSound.Parent = gui

-- Other Tab (rightPanel)
local rightTitle = createTransparentLabel("ESP & Other Features", rightPanel)
rightTitle.TextColor3 = Color3.fromRGB(150, 200, 255)
rightTitle.Font = Enum.Font.GothamBold
rightTitle.TextSize = 14

local playerList = Instance.new("ScrollingFrame")
playerList.Size = UDim2.new(1, 0, 0, 110)
playerList.BackgroundTransparency = 1
playerList.BorderSizePixel = 0
playerList.ScrollBarThickness = 4
playerList.CanvasSize = UDim2.new(0, 0, 0, 0)
playerList.Parent = rightPanel
local playerListLayout = Instance.new("UIListLayout")
playerListLayout.Parent = playerList
playerListLayout.SortOrder = Enum.SortOrder.LayoutOrder
playerListLayout.Padding = UDim.new(0, 2)

local autoNameESP = createTransparentButton("Auto ESP Name: OFF", Color3.fromRGB(50, 150, 200), rightPanel)
local refreshBtn = createTransparentButton("Refresh Player List", Color3.fromRGB(80, 80, 180), rightPanel)
local espNameAllBtn = createTransparentButton("ESP Name All: OFF", Color3.fromRGB(80, 200, 80), rightPanel)
local boxESPBtn = createTransparentButton("ESP Box Charm: OFF", Color3.fromRGB(200, 200, 80), rightPanel)

-- Tab switching logic
local function switchTab(tabIndex)
	if tabIndex == 1 then
		leftPanel.Visible = true
		rightPanel.Visible = false
		tab1Btn.BackgroundTransparency = 0.2
		tab2Btn.BackgroundTransparency = 0.6
	else
		leftPanel.Visible = false
		rightPanel.Visible = true
		tab1Btn.BackgroundTransparency = 0.6
		tab2Btn.BackgroundTransparency = 0.2
	end
end

tab1Btn.MouseButton1Click:Connect(function() switchTab(1) end)
tab2Btn.MouseButton1Click:Connect(function() switchTab(2) end)
switchTab(1)

-- Close Button
local closeButton = Instance.new("TextButton")
closeButton.Size = UDim2.new(0, 28, 0, 28)
closeButton.Position = UDim2.new(1, -32, 0, 2)
closeButton.Text = "X"
closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
closeButton.BackgroundTransparency = 1
closeButton.BorderSizePixel = 0
closeButton.Font = Enum.Font.GothamBold
closeButton.TextSize = 16
closeButton.Parent = mainFrame

-- Player selection list & selected players table
local selectedPlayers = {}

local function updatePlayerList()
	for _, child in pairs(playerList:GetChildren()) do
		if child:IsA("TextButton") then child:Destroy() end
	end
	local yPos = 0
	for _, player in ipairs(Players:GetPlayers()) do
		if player ~= LocalPlayer then
			local playerBtn = Instance.new("TextButton")
			playerBtn.Size = UDim2.new(1, -6, 0, 28)
			playerBtn.Text = player.Name
			local bg = selectedPlayers[player] and Color3.fromRGB(80, 160, 80) or Color3.fromRGB(60, 60, 60)
			playerBtn.BackgroundColor3 = bg
			playerBtn.BackgroundTransparency = 0.7
			playerBtn.TextColor3 = Color3.new(1, 1, 1)
			playerBtn.Font = Enum.Font.Gotham
			playerBtn.TextSize = 14
			playerBtn.BorderSizePixel = 0
			playerBtn.Parent = playerList
			local btnCorner = Instance.new("UICorner")
			btnCorner.CornerRadius = UDim.new(0, 4)
			btnCorner.Parent = playerBtn
			playerBtn.MouseButton1Click:Connect(function()
				selectedPlayers[player] = not selectedPlayers[player]
				playerBtn.BackgroundColor3 = selectedPlayers[player] and Color3.fromRGB(80, 160, 80) or Color3.fromRGB(60, 60, 60)
				if nameESPEnabled then
					if selectedPlayers[player] and player.Character then
						createNameESPForPlayer(player)
					else
						if player.Character then
							local head = player.Character:FindFirstChild("Head")
							if head then
								local billboard = head:FindFirstChild("NameESP")
								if billboard then pcall(function() billboard:Destroy() end) end
							end
						end
					end
				end
			end)
			yPos = yPos + 30
		end
	end
	playerList.CanvasSize = UDim2.new(0, 0, 0, yPos)
end

-- Loopspeed logic (keeps WalkSpeed up to date)
local loopspeedEnabled = false
local loopspeedConnection = nil

local function setLoopspeedEnabled(state)
	loopspeedEnabled = state
	loopspeedToggle.Text = loopspeedEnabled and "Loopspeed: ON" or "Loopspeed: OFF"
	loopspeedToggle.BackgroundColor3 = loopspeedEnabled and Color3.fromRGB(80, 200, 80) or Color3.fromRGB(80, 80, 200)
	if loopspeedConnection then
		pcall(function() loopspeedConnection:Disconnect() end)
		loopspeedConnection = nil
	end
	if loopspeedEnabled then
		loopspeedConnection = RunService.Heartbeat:Connect(function()
			local character = LocalPlayer.Character
			if character then
				local humanoid = character:FindFirstChildOfClass("Humanoid")
				if humanoid then
					local speedValue = tonumber(loopspeedInput.Text) or 16
					pcall(function() humanoid.WalkSpeed = speedValue end)
				end
			end
		end)
	else
		local character = LocalPlayer.Character
		if character then
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			if humanoid then
				pcall(function() humanoid.WalkSpeed = 16 end)
			end
		end
	end
end

-- GUI Wiring
loopspeedToggle.MouseButton1Click:Connect(function()
	setLoopspeedEnabled(not loopspeedEnabled)
end)

loopspeedInput.FocusLost:Connect(function(enterPressed)
	if loopspeedEnabled then
		setLoopspeedEnabled(true) -- reapply with new value
	end
end)

toggleUIButton.MouseButton1Click:Connect(function()
	mainFrame.Visible = not mainFrame.Visible
	toggleUIButton.Text = mainFrame.Visible and "☰ Close Menu" or "☰ Open Menu"
	if mainFrame.Visible then updatePlayerList() end
end)

closeButton.MouseButton1Click:Connect(function()
	mainFrame.Visible = false
	toggleUIButton.Text = "☰ Open Menu"
end)

-- AUTO HITBOX TOGGLE
autoToggle.MouseButton1Click:Connect(function()
	autoHitboxEnabled = not autoHitboxEnabled
	autoToggle.Text = autoHitboxEnabled and "Auto Hitbox: ON" or "Auto Hitbox: OFF"
	autoToggle.BackgroundColor3 = autoHitboxEnabled and Color3.fromRGB(50, 180, 50) or Color3.fromRGB(180, 50, 50)
	if autoHitboxEnabled then
		for _, player in ipairs(Players:GetPlayers()) do
			if player ~= LocalPlayer and player.Character then
				applyHeadHitboxToPlayer(player, tonumber(sizeInput.Text) or DEFAULT_HITBOX_SIZE)
			end
		end
	else
		for _, player in ipairs(Players:GetPlayers()) do
			removeAllForPlayer(player)
		end
	end
	statusLabel.Text = "Processing: " .. tableCount(playerData) .. " Players"
end)

removeAllBtn.MouseButton1Click:Connect(function()
	for _, player in ipairs(Players:GetPlayers()) do
		if player ~= LocalPlayer then
			removeAllForPlayer(player)
		end
	end
	statusLabel.Text = "Processing: 0 Players"
end)

-- Auto/Manual Name ESP
nameESPEnabled = false
autoNameESP.MouseButton1Click:Connect(function()
	nameESPEnabled = not nameESPEnabled
	autoNameESP.Text = nameESPEnabled and "Auto ESP Name: ON" or "Auto ESP Name: OFF"
	autoNameESP.BackgroundColor3 = nameESPEnabled and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(50, 150, 200)
	if not nameESPEnabled then
		for _, p in ipairs(Players:GetPlayers()) do
			if p.Character and p ~= LocalPlayer then
				local head = p.Character:FindFirstChild("Head")
				if head then
					local billboard = head:FindFirstChild("NameESP")
					if billboard then pcall(function() billboard:Destroy() end) end
				end
			end
		end
	else
		for p, _ in pairs(selectedPlayers) do
			if selectedPlayers[p] and p.Character then
				createNameESPForPlayer(p)
			end
		end
	end
end)

refreshBtn.MouseButton1Click:Connect(function()
	updatePlayerList()
end)

-- ESP Name All toggle
espNameAllBtn.MouseButton1Click:Connect(function()
	espNameAllState = not espNameAllState
	espNameAllBtn.Text = espNameAllState and "ESP Name All: ON" or "ESP Name All: OFF"
	espNameAllBtn.BackgroundColor3 = espNameAllState and Color3.fromRGB(80, 220, 80) or Color3.fromRGB(80, 200, 80)
	for _, player in ipairs(Players:GetPlayers()) do
		if player ~= LocalPlayer then
			selectedPlayers[player] = espNameAllState
			if espNameAllState and player.Character then
				createNameESPForPlayer(player)
			else
				if player.Character then
					local head = player.Character:FindFirstChild("Head")
					if head then
						local billboard = head:FindFirstChild("NameESP")
						if billboard then pcall(function() billboard:Destroy() end) end
					end
				end
			end
		end
	end
	updatePlayerList()
end)

-- Box ESP toggle
boxESPBtn.MouseButton1Click:Connect(function()
	boxESPEnabled = not boxESPEnabled
	boxESPBtn.Text = boxESPEnabled and "ESP Box Charm: ON" or "ESP Box Charm: OFF"
	boxESPBtn.BackgroundColor3 = boxESPEnabled and Color3.fromRGB(220, 220, 80) or Color3.fromRGB(200, 200, 80)
	for _, player in ipairs(Players:GetPlayers()) do
		if player ~= LocalPlayer and player.Character then
			local size = tonumber(sizeInput.Text) or DEFAULT_HITBOX_SIZE
			local color = getTeamColor(player)
			if boxESPEnabled then
				addBoxESPToCharacter(player.Character, color, size)
			else
				local head = player.Character:FindFirstChild("Head")
				if head then
					local box = head:FindFirstChild("BoxCharmESP")
					if box then pcall(function() box:Destroy() end) end
				end
			end
		end
	end
end)

-- Invisibility Button logic
invisButton.MouseButton1Click:Connect(toggleInvisibility)
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then return end
	if input.KeyCode == INVIS_CONFIG.TOGGLE_KEY then toggleInvisibility() end
end)

-- Ensure invis state reset on respawn
LocalPlayer.CharacterAdded:Connect(function(character)
	isInvisible = false
	if invisButton then
		invisButton.BackgroundColor3 = INVIS_CONFIG.PRIMARY_COLOR
		invisButton.Text = "INVISIBLE"
	end
	local invisChair = workspace:FindFirstChild("invischair")
	if invisChair then
		pcall(function() invisChair:Destroy() end)
	end
	setCharacterTransparency(character, 0)
end)

-- Clean up when local player leaves (safety)
Players.PlayerRemoving:Connect(function(leavingPlayer)
	if leavingPlayer == LocalPlayer then
		local invisChair = workspace:FindFirstChild("invischair")
		if invisChair then pcall(function() invisChair:Destroy() end) end
	end
end)

-- When other players join, set up handling and reapply if needed
Players.PlayerAdded:Connect(function(player)
	-- Do not process local player
	if player == LocalPlayer then return end
	handlePlayer(player)
	-- If ESP All state active, ensure selected state and creation
	if espNameAllState then
		selectedPlayers[player] = true
		if player.Character then createNameESPForPlayer(player) end
	end
end)

-- When players leave, remove everything immediately
Players.PlayerRemoving:Connect(function(player)
	removeAllForPlayer(player)
	selectedPlayers[player] = nil
end)

-- Initialize handlers for existing players and apply if toggles on
for _, player in ipairs(Players:GetPlayers()) do
	if player ~= LocalPlayer then
		handlePlayer(player)
		-- initial application if enabled
		if autoHitboxEnabled and player.Character then
			applyHeadHitboxToPlayer(player, tonumber(sizeInput.Text) or DEFAULT_HITBOX_SIZE)
		end
		if boxESPEnabled and player.Character then
			addBoxESPToCharacter(player.Character, getTeamColor(player), tonumber(sizeInput.Text) or DEFAULT_HITBOX_SIZE)
		end
		if espNameAllState and player.Character then
			selectedPlayers[player] = true
			createNameESPForPlayer(player)
		end
	end
end

-- Safety periodic sweep: ensure hitboxes are applied to everyone while auto enabled
task.spawn(function()
	while true do
		task.wait(5)
		if autoHitboxEnabled then
			for _, player in ipairs(Players:GetPlayers()) do
				if player ~= LocalPlayer then
					-- only apply if character exists and not already applied
					local size = tonumber(sizeInput.Text) or DEFAULT_HITBOX_SIZE
					if player.Character then
						playerData[player] = playerData[player] or {}
						if not (playerData[player].applied and playerData[player].lastSize == size) then
							applyHeadHitboxToPlayer(player, size)
						end
					end
				end
			end
			statusLabel.Text = "Processing: " .. tableCount(playerData) .. " Players"
		else
			-- keep status accurate even when disabled
			statusLabel.Text = "Processing: " .. tableCount(playerData) .. " Players"
		end
	end
end)

-- Ensure player list UI is accurate initially
updatePlayerList()

-- End of script