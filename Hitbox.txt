-- Combined Head Hitbox & Invisibility GUI (Mobile Tab Version)
-- Rewritten to robustly apply/remove hitboxes and ESP for all players (except LocalPlayer).
-- Ensures complete cleanup on death/character removal and automatic reapplication on respawn.

-- SERVICES
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer

-- CONFIG
local DEFAULT_HITBOX_SIZE = 4
local ESP_COLOR = Color3.fromRGB(255, 150, 150)
local ESP_TRANSPARENCY = 0.7
local ESP_OUTLINE_COLOR = Color3.fromRGB(255, 255, 0)
local ESP_OUTLINE_TRANSPARENCY = 0
local TEXT_ESP_COLOR = Color3.fromRGB(255, 255, 255)

local INVIS_CONFIG = {
	TOGGLE_KEY = Enum.KeyCode.X,
	SOUND_ID = "rbxassetid://942127495",
	INVISIBILITY_POSITION = Vector3.new(-25.95, 84, 3537.55),
	NOTIFICATION_DURATION = 3,
	BACKGROUND_COLOR = Color3.fromRGB(25, 25, 25),
	PRIMARY_COLOR = Color3.fromRGB(0, 170, 255),
	SUCCESS_COLOR = Color3.fromRGB(46, 204, 113),
	TEXT_COLOR = Color3.fromRGB(255, 255, 255),
}

-- STATE
local processedPlayers = {}         -- player -> true if hitbox applied
local playerData = {}               -- player -> table of stored data & connections
local autoHitboxEnabled = false
local nameESPEnabled = false
local boxESPEnabled = false
local selectedPlayers = {}          -- player -> bool (selected in UI)
local espNameAllState = false

-- Invisibility State
local isInvisible = false
local invisButton
local invisSound

-- UTIL
local function tableCount(t)
	local count = 0
	for _ in pairs(t) do count = count + 1 end
	return count
end

local function getTeamColor(player)
	if player and player.Team and player.Team.TeamColor then
		return player.Team.TeamColor.Color
	end
	return ESP_COLOR
end

local function createNotification(title, text)
	StarterGui:SetCore("SendNotification", {
		Title = title,
		Text = text,
		Duration = INVIS_CONFIG.NOTIFICATION_DURATION,
	})
end

local function setCharacterTransparency(character, transparency)
	if not character then return end
	for _, descendant in ipairs(character:GetDescendants()) do
		if descendant:IsA("BasePart") or descendant:IsA("Decal") then
			-- only change transparency on parts that exist (avoid changing UI elements)
			pcall(function()
				descendant.Transparency = transparency
			end)
		end
	end
end

local function getHumanoidRootPart()
	local char = LocalPlayer.Character
	if not char then return nil end
	return char:FindFirstChild("HumanoidRootPart")
end

local function playInvisSound()
	if invisSound then
		pcall(function() invisSound:Play() end)
	end
end

-- CLEANUP helpers for a single player
local function disconnectAndClearConnections(data)
	if not data then return end
	if data.nameConnection and data.nameConnection.Connected then
		data.nameConnection:Disconnect()
	end
	if data.boxHeartbeatConn and data.boxHeartbeatConn.Connected then
		data.boxHeartbeatConn:Disconnect()
	end
	if data.charAddedConn and data.charAddedConn.Connected then
		data.charAddedConn:Disconnect()
	end
	if data.charAncestryConn and data.charAncestryConn.Connected then
		data.charAncestryConn:Disconnect()
	end
	if data.humanoidDiedConn and data.humanoidDiedConn.Connected then
		data.humanoidDiedConn:Disconnect()
	end
end

local function removeNameESPForPlayer(player)
	local data = playerData[player]
	if data and data.nameBillboard then
		if data.nameBillboard.Parent then
			data.nameBillboard:Destroy()
		end
		data.nameBillboard = nil
	end
	if data then
		if data.nameConnection and data.nameConnection.Connected then
			data.nameConnection:Disconnect()
			data.nameConnection = nil
		end
	end
end

local function removeBoxESPForPlayer(player)
	local data = playerData[player]
	if data and data.boxAdornment then
		if data.boxAdornment.Parent then
			data.boxAdornment:Destroy()
		end
		data.boxAdornment = nil
	end
	if data and data.boxHeartbeatConn and data.boxHeartbeatConn.Connected then
		data.boxHeartbeatConn:Disconnect()
		data.boxHeartbeatConn = nil
	end
end

local function restoreHeadForPlayer(player)
	local data = playerData[player]
	if not data then return end
	local char = player.Character
	if not char then
		-- try to restore using stored info even if char nil (restore mesh in stored condition)
		-- nothing to do if no char
		return
	end
	local head = char:FindFirstChild("Head")
	if not head then return end
	-- restore original mesh & size
	if head:FindFirstChild("OriginalSize") then
		local orig = head.OriginalSize.Value
		head.Size = orig
		head.OriginalSize:Destroy()
	end
	if data.meshBackup and not head:FindFirstChild("Mesh") then
		-- reparent backup mesh if possible
		local ok, err = pcall(function()
			data.meshBackup.Parent = head
		end)
		if not ok then
			-- could not restore; just clear backup
			data.meshBackup = nil
		end
	end
	pcall(function()
		head.Transparency = 0
		head.CanCollide = true
		head.Massless = false
		head.Material = Enum.Material.Plastic
	end)
end

local function removeHitboxAndESPForPlayer(player)
	-- Completely remove everything related to this player
	if not player then return end
	local data = playerData[player]
	-- Restore head properties if character still exists
	restoreHeadForPlayer(player)
	-- Remove name ESP
	removeNameESPForPlayer(player)
	-- Remove box ESP
	removeBoxESPForPlayer(player)
	-- Mark not processed
	processedPlayers[player] = nil
	-- Disconnect saved connections and clear data entries
	if data then
		disconnectAndClearConnections(data)
		-- clear stored mesh backup (if it exists but never restored)
		data.meshBackup = nil
		playerData[player] = nil
	end
end

-- APPLY hitbox
local function applyHeadHitboxToPlayer(player, size)
	if not player or player == LocalPlayer then return end
	local char = player.Character
	if not char then return end
	local head = char:FindFirstChild("Head")
	if not head or not head:IsA("BasePart") then return end

	playerData[player] = playerData[player] or {}
	local data = playerData[player]

	-- prevent double-application
	if processedPlayers[player] then
		-- update size if already processed
		pcall(function()
			head.Size = Vector3.new(size, size, size)
		end)
		return
	end

	-- store original size
	if not head:FindFirstChild("OriginalSize") then
		local original = Instance.new("Vector3Value")
		original.Name = "OriginalSize"
		original.Value = head.Size
		original.Parent = head
	end

	-- backup mesh if present
	local mesh = head:FindFirstChild("Mesh") or head:FindFirstChildOfClass("SpecialMesh") or head:FindFirstChildOfClass("Mesh")
	if mesh then
		-- save clone for restore
		data.meshBackup = mesh:Clone()
		mesh:Destroy()
	end

	-- apply hitbox properties
	pcall(function()
		head.Massless = true
		head.Size = Vector3.new(size, size, size)
		head.CanCollide = false
		head.Transparency = 0.5
		head.Material = Enum.Material.ForceField
	end)

	-- Connect to humanoid death to cleanup immediately on death
	local humanoid = char:FindFirstChildOfClass("Humanoid")
	if humanoid then
		-- ensure any previous connection is cleared
		if data.humanoidDiedConn and data.humanoidDiedConn.Connected then
			data.humanoidDiedConn:Disconnect()
		end
		data.humanoidDiedConn = humanoid.Died:Connect(function()
			-- Immediate cleanup upon death
			removeHitboxAndESPForPlayer(player)
		end)
	end

	-- Connect to ancestry changed on the character to cleanup when character is removed from workspace
	if data.charAncestryConn and data.charAncestryConn.Connected then
		data.charAncestryConn:Disconnect()
	end
	data.charAncestryConn = char.AncestryChanged:Connect(function(_, parent)
		if not parent then
			-- character removed -> cleanup visual elements
			removeHitboxAndESPForPlayer(player)
		end
	end)

	processedPlayers[player] = true
end

-- BOX ESP
local function addBoxESPForPlayer(player, size)
	if not player or player == LocalPlayer then return end
	local char = player.Character
	if not char then return end
	local head = char:FindFirstChild("Head")
	if not head or not head:IsA("BasePart") then return end

	playerData[player] = playerData[player] or {}
	local data = playerData[player]

	-- remove existing box before adding
	removeBoxESPForPlayer(player)

	local box = Instance.new("BoxHandleAdornment")
	box.Name = "BoxCharmESP"
	box.Adornee = head
	box.Size = Vector3.new(size, size, size)
	box.Color3 = getTeamColor(player)
	box.Transparency = ESP_TRANSPARENCY
	box.ZIndex = 10
	box.AlwaysOnTop = true
	box.Parent = head
	data.boxAdornment = box

	-- update color/size every heartbeat to follow team changes or size changes
	if data.boxHeartbeatConn and data.boxHeartbeatConn.Connected then
		data.boxHeartbeatConn:Disconnect()
	end
	data.boxHeartbeatConn = RunService.Heartbeat:Connect(function()
		if not data or not data.boxAdornment or not data.boxAdornment.Parent or not player.Character or not player.Character:FindFirstChild("Head") then
			-- stop if something invalid
			if data and data.boxHeartbeatConn then
				data.boxHeartbeatConn:Disconnect()
				data.boxHeartbeatConn = nil
			end
			return
		end
		local currentHead = player.Character:FindFirstChild("Head")
		if currentHead then
			data.boxAdornment.Adornee = currentHead
			data.boxAdornment.Size = Vector3.new(size, size, size)
			data.boxAdornment.Color3 = getTeamColor(player)
		end
	end)
end

-- NAME ESP
local function createNameESPForPlayer(player)
	if not player or player == LocalPlayer then return end
	local char = player.Character
	if not char then removeNameESPForPlayer(player); return end
	local head = char:FindFirstChild("Head")
	if not head then removeNameESPForPlayer(player); return end

	playerData[player] = playerData[player] or {}
	local data = playerData[player]

	-- remove existing first
	removeNameESPForPlayer(player)

	-- create billboard
	local billboard = Instance.new("BillboardGui")
	billboard.Name = "NameESP"
	billboard.Adornee = head
	billboard.Size = UDim2.new(0, 200, 0, 50)
	billboard.StudsOffset = Vector3.new(0, 2.5, 0)
	billboard.AlwaysOnTop = true
	billboard.MaxDistance = 1000
	billboard.Parent = head

	local nameLabel = Instance.new("TextLabel")
	nameLabel.Size = UDim2.new(1, 0, 0.5, 0)
	nameLabel.Position = UDim2.new(0, 0, 0, 0)
	nameLabel.BackgroundTransparency = 1
	nameLabel.Text = player.Name
	nameLabel.TextColor3 = getTeamColor(player)
	nameLabel.TextStrokeTransparency = 0
	nameLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
	nameLabel.Font = Enum.Font.GothamBold
	nameLabel.TextSize = 14
	nameLabel.Parent = billboard

	local distanceLabel = Instance.new("TextLabel")
	distanceLabel.Size = UDim2.new(1, 0, 0.5, 0)
	distanceLabel.Position = UDim2.new(0, 0, 0.5, 0)
	distanceLabel.BackgroundTransparency = 1
	distanceLabel.Text = "0m"
	distanceLabel.TextColor3 = TEXT_ESP_COLOR
	distanceLabel.TextStrokeTransparency = 0
	distanceLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
	distanceLabel.Font = Enum.Font.Gotham
	distanceLabel.TextSize = 12
	distanceLabel.Parent = billboard

	data.nameBillboard = billboard

	-- heartbeat update for distance and color
	if data.nameConnection and data.nameConnection.Connected then
		data.nameConnection:Disconnect()
	end
	data.nameConnection = RunService.Heartbeat:Connect(function()
		if not data or not data.nameBillboard or not data.nameBillboard.Parent or not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("Head") then
			if data and data.nameConnection then
				data.nameConnection:Disconnect()
				data.nameConnection = nil
			end
			return
		end
		local localHead = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Head")
		local otherHead = player.Character and player.Character:FindFirstChild("Head")
		if localHead and otherHead then
			local distance = (otherHead.Position - localHead.Position).Magnitude
			distanceLabel.Text = string.format("%.1fm", distance)
		else
			distanceLabel.Text = ""
		end
		nameLabel.TextColor3 = getTeamColor(player)
	end)
end

-- HANDLE player lifecycle: ensure we apply on respawn, and fully cleanup on death/leaving
local function setupPlayerLifecycle(player)
	if player == LocalPlayer then return end

	-- ensure data table exists
	playerData[player] = playerData[player] or {}
	local data = playerData[player]

	-- CharacterAdded: reapply based on current toggles and selections
	if data.charAddedConn and data.charAddedConn.Connected then
		data.charAddedConn:Disconnect()
	end
	data.charAddedConn = player.CharacterAdded:Connect(function(char)
		-- small wait to let character parts exist
		task.wait(0.15)
		-- reapply head hitbox if auto-enabling or previously selected/processed
		local size = tonumber(sizeInput.Text) or DEFAULT_HITBOX_SIZE
		if autoHitboxEnabled or processedPlayers[player] then
			applyHeadHitboxToPlayer(player, size)
		end
		-- box ESP
		if boxESPEnabled then
			addBoxESPForPlayer(player, size)
		end
		-- name ESP: if either global nameESPEnabled or espNameAllState or selectedPlayers[player]
		if nameESPEnabled or espNameAllState or selectedPlayers[player] then
			createNameESPForPlayer(player)
		end

		-- connect humanoid died on new character to ensure immediate cleanup on death
		local humanoid = char:FindFirstChildOfClass("Humanoid")
		if humanoid then
			if data.humanoidDiedConn and data.humanoidDiedConn.Connected then
				data.humanoidDiedConn:Disconnect()
			end
			data.humanoidDiedConn = humanoid.Died:Connect(function()
				-- On death, remove ALL visuals right away
				removeHitboxAndESPForPlayer(player)
			end)
		end

		-- watch for character removal/ancestry change to cleanup
		if data.charAncestryConn and data.charAncestryConn.Connected then
			data.charAncestryConn:Disconnect()
		end
		data.charAncestryConn = char.AncestryChanged:Connect(function(_, parent)
			if not parent then
				-- character removed -> cleanup visuals for this player
				removeHitboxAndESPForPlayer(player)
			end
		end)
	end)

	-- If the player already has a character at setup time, trigger immediate application
	if player.Character then
		-- short wait so CharacterAdded has finished constructing parts
		task.spawn(function()
			task.wait(0.1)
			local size = tonumber(sizeInput.Text) or DEFAULT_HITBOX_SIZE
			if autoHitboxEnabled then
				applyHeadHitboxToPlayer(player, size)
			end
			if boxESPEnabled then
				addBoxESPForPlayer(player, size)
			end
			if nameESPEnabled or espNameAllState or selectedPlayers[player] then
				createNameESPForPlayer(player)
			end
		end)
	end

	-- Player leaving: ensure full cleanup
	if not playerData[player].leavingConn then
		playerData[player].leavingConn = player.AncestryChanged:Connect(function(_, parent)
			if not parent then
				-- Player instance removed -> cleanup everything
				removeHitboxAndESPForPlayer(player)
			end
		end)
	end
end

-- UI HELPER CREATION (kept similar to original, but wiring uses the robust functions)
local function createTransparentButton(text, color, parent)
	local btn = Instance.new("TextButton")
	btn.Size = UDim2.new(1, 0, 0, 32)
	btn.Text = text
	btn.BackgroundColor3 = color
	btn.BackgroundTransparency = 0.7
	btn.TextColor3 = Color3.new(1, 1, 1)
	btn.Font = Enum.Font.Gotham
	btn.TextSize = 14
	btn.BorderSizePixel = 0
	btn.Parent = parent
	local btnCorner = Instance.new("UICorner")
	btnCorner.CornerRadius = UDim.new(0, 4)
	btnCorner.Parent = btn
	return btn
end

local function createTransparentInput(placeholder, text, parent)
	local input = Instance.new("TextBox")
	input.Size = UDim2.new(1, 0, 0, 32)
	input.PlaceholderText = placeholder
	input.Text = text
	input.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
	input.BackgroundTransparency = 0.7
	input.TextColor3 = Color3.new(1, 1, 1)
	input.Font = Enum.Font.Gotham
	input.TextSize = 14
	input.BorderSizePixel = 0
	input.Parent = parent
	local inputCorner = Instance.new("UICorner")
	inputCorner.CornerRadius = UDim.new(0, 4)
	inputCorner.Parent = input
	return input
end

local function createTransparentLabel(text, parent)
	local label = Instance.new("TextLabel")
	label.Size = UDim2.new(1, 0, 0, 22)
	label.BackgroundTransparency = 1
	label.Text = text
	label.TextColor3 = Color3.fromRGB(200, 200, 200)
	label.Font = Enum.Font.Gotham
	label.TextSize = 12
	label.TextXAlignment = Enum.TextXAlignment.Left
	label.Parent = parent
	return label
end

-- UI SETUP (Mobile size)
local gui = Instance.new("ScreenGui")
gui.Name = "Mobile_ESP_GUI"
gui.ResetOnSpawn = false
gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
gui.Parent = LocalPlayer:WaitForChild("PlayerGui")

local mainContainer = Instance.new("Frame")
mainContainer.Size = UDim2.new(0, 220, 0, 36)
mainContainer.Position = UDim2.new(0.5, -110, 0, 10)
mainContainer.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
mainContainer.BackgroundTransparency = 0.7
mainContainer.BorderSizePixel = 0
mainContainer.Active = true
mainContainer.Draggable = true
mainContainer.Parent = gui
local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0, 8)
corner.Parent = mainContainer

local toggleUIButton = Instance.new("TextButton")
toggleUIButton.Size = UDim2.new(0, 110, 0, 28)
toggleUIButton.Position = UDim2.new(0.5, -55, 0.5, -14)
toggleUIButton.Text = "☰ Open Menu"
toggleUIButton.TextColor3 = Color3.fromRGB(255, 255, 255)
toggleUIButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
toggleUIButton.BackgroundTransparency = 0.7
toggleUIButton.BorderSizePixel = 0
toggleUIButton.Font = Enum.Font.Gotham
toggleUIButton.TextSize = 14
toggleUIButton.Parent = mainContainer
local buttonCorner = Instance.new("UICorner")
buttonCorner.CornerRadius = UDim.new(0, 6)
buttonCorner.Parent = toggleUIButton

local mainFrame = Instance.new("Frame")
mainFrame.Size = UDim2.new(0, 220, 0, 380)
mainFrame.Position = UDim2.new(0.5, -110, 0.5, -190)
mainFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
mainFrame.BackgroundTransparency = 0.7
mainFrame.BorderSizePixel = 0
mainFrame.Visible = false
mainFrame.Active = true
mainFrame.Draggable = true
mainFrame.Parent = gui
local mainCorner = Instance.new("UICorner")
mainCorner.CornerRadius = UDim.new(0, 8)
mainCorner.Parent = mainFrame

-- Tab Bar
local tabBar = Instance.new("Frame")
tabBar.Size = UDim2.new(1, 0, 0, 32)
tabBar.Position = UDim2.new(0, 0, 0, 0)
tabBar.BackgroundTransparency = 1
tabBar.Parent = mainFrame

local tab1Btn = Instance.new("TextButton")
tab1Btn.Size = UDim2.new(0.5, -2, 1, 0)
tab1Btn.Position = UDim2.new(0, 0, 0, 0)
tab1Btn.Text = "HeadHitbox"
tab1Btn.TextColor3 = Color3.fromRGB(255, 255, 255)
tab1Btn.BackgroundColor3 = Color3.fromRGB(220, 60, 60)
tab1Btn.BackgroundTransparency = 0.2
tab1Btn.Font = Enum.Font.GothamBold
tab1Btn.TextSize = 14
tab1Btn.BorderSizePixel = 0
tab1Btn.Parent = tabBar
local tab1Corner = Instance.new("UICorner")
tab1Corner.CornerRadius = UDim.new(0, 6)
tab1Corner.Parent = tab1Btn

local tab2Btn = Instance.new("TextButton")
tab2Btn.Size = UDim2.new(0.5, -2, 1, 0)
tab2Btn.Position = UDim2.new(0.5, 2, 0, 0)
tab2Btn.Text = "Other"
tab2Btn.TextColor3 = Color3.fromRGB(255, 255, 255)
tab2Btn.BackgroundColor3 = Color3.fromRGB(60, 120, 220)
tab2Btn.BackgroundTransparency = 0.2
tab2Btn.Font = Enum.Font.GothamBold
tab2Btn.TextSize = 14
tab2Btn.BorderSizePixel = 0
tab2Btn.Parent = tabBar
local tab2Corner = Instance.new("UICorner")
tab2Corner.CornerRadius = UDim.new(0, 6)
tab2Corner.Parent = tab2Btn

-- Tab Panels
local leftPanel = Instance.new("Frame")
leftPanel.Size = UDim2.new(1, -12, 1, -44)
leftPanel.Position = UDim2.new(0, 6, 0, 38)
leftPanel.BackgroundTransparency = 1
leftPanel.BorderSizePixel = 0
leftPanel.Visible = true
leftPanel.Parent = mainFrame

local rightPanel = Instance.new("ScrollingFrame")
rightPanel.Size = UDim2.new(1, -12, 1, -44)
rightPanel.Position = UDim2.new(0, 6, 0, 38)
rightPanel.BackgroundTransparency = 1
rightPanel.BorderSizePixel = 0
rightPanel.ScrollBarThickness = 4
rightPanel.CanvasSize = UDim2.new(0, 0, 0, 0)
rightPanel.Visible = false
rightPanel.Parent = mainFrame

-- UIListLayout cho leftPanel
local leftLayout = Instance.new("UIListLayout")
leftLayout.Parent = leftPanel
leftLayout.SortOrder = Enum.SortOrder.LayoutOrder
leftLayout.Padding = UDim.new(0, 4)

-- UIListLayout cho rightPanel
local rightLayout = Instance.new("UIListLayout")
rightLayout.Parent = rightPanel
rightLayout.SortOrder = Enum.SortOrder.LayoutOrder
rightLayout.Padding = UDim.new(0, 4)

-- HeadHitbox Tab (leftPanel)
local leftTitle = createTransparentLabel("Head hitbox", leftPanel)
leftTitle.TextColor3 = Color3.fromRGB(255, 150, 150)
leftTitle.Font = Enum.Font.GothamBold
leftTitle.TextSize = 14

local sizeInput = createTransparentInput("Size (e.g. 4)", tostring(DEFAULT_HITBOX_SIZE), leftPanel)
local autoToggle = createTransparentButton("Auto Hitbox: OFF", Color3.fromRGB(180, 50, 50), leftPanel)
local removeAllBtn = createTransparentButton("Remove All Hitboxes", Color3.fromRGB(180, 50, 50), leftPanel)
local statusLabel = createTransparentLabel("Processing: 0 Players", leftPanel)
local loopspeedLabel = createTransparentLabel("Loopspeed", leftPanel)
local loopspeedInput = createTransparentInput("Speed (e.g. 16)", "16", leftPanel)
local loopspeedToggle = createTransparentButton("Loopspeed: OFF", Color3.fromRGB(80, 80, 200), leftPanel)
invisButton = createTransparentButton("INVISIBLE", INVIS_CONFIG.PRIMARY_COLOR, leftPanel)

-- Sound for invisibility toggle
invisSound = Instance.new("Sound")
invisSound.Name = "ToggleSound"
invisSound.SoundId = INVIS_CONFIG.SOUND_ID
invisSound.Volume = 0.5
invisSound.Parent = gui

-- Other Tab (rightPanel)
local rightTitle = createTransparentLabel("ESP & Other Features", rightPanel)
rightTitle.TextColor3 = Color3.fromRGB(150, 200, 255)
rightTitle.Font = Enum.Font.GothamBold
rightTitle.TextSize = 14

local playerList = Instance.new("ScrollingFrame")
playerList.Size = UDim2.new(1, 0, 0, 110)
playerList.BackgroundTransparency = 1
playerList.BorderSizePixel = 0
playerList.ScrollBarThickness = 4
playerList.CanvasSize = UDim2.new(0, 0, 0, 0)
playerList.Parent = rightPanel
local playerListLayout = Instance.new("UIListLayout")
playerListLayout.Parent = playerList
playerListLayout.SortOrder = Enum.SortOrder.LayoutOrder
playerListLayout.Padding = UDim.new(0, 2)

local autoNameESP = createTransparentButton("Auto ESP Name: OFF", Color3.fromRGB(50, 150, 200), rightPanel)
local refreshBtn = createTransparentButton("Refresh Player List", Color3.fromRGB(80, 80, 180), rightPanel)
local espNameAllBtn = createTransparentButton("ESP Name All: OFF", Color3.fromRGB(80, 200, 80), rightPanel)
local boxESPBtn = createTransparentButton("ESP Box Charm: OFF", Color3.fromRGB(200, 200, 80), rightPanel)

-- Tab switching logic
local function switchTab(tabIndex)
	if tabIndex == 1 then
		leftPanel.Visible = true
		rightPanel.Visible = false
		tab1Btn.BackgroundTransparency = 0.2
		tab2Btn.BackgroundTransparency = 0.6
	else
		leftPanel.Visible = false
		rightPanel.Visible = true
		tab1Btn.BackgroundTransparency = 0.6
		tab2Btn.BackgroundTransparency = 0.2
	end
end

tab1Btn.MouseButton1Click:Connect(function() switchTab(1) end)
tab2Btn.MouseButton1Click:Connect(function() switchTab(2) end)
switchTab(1)

-- Close Button
local closeButton = Instance.new("TextButton")
closeButton.Size = UDim2.new(0, 28, 0, 28)
closeButton.Position = UDim2.new(1, -32, 0, 2)
closeButton.Text = "X"
closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
closeButton.BackgroundTransparency = 1
closeButton.BorderSizePixel = 0
closeButton.Font = Enum.Font.GothamBold
closeButton.TextSize = 16
closeButton.Parent = mainFrame

-- update player list UI
local function updatePlayerList()
	for _, child in pairs(playerList:GetChildren()) do
		if child:IsA("TextButton") then child:Destroy() end
	end
	local yPos = 0
	for _, player in pairs(Players:GetPlayers()) do
		if player ~= LocalPlayer then
			local playerBtn = Instance.new("TextButton")
			playerBtn.Size = UDim2.new(1, -6, 0, 28)
			playerBtn.Text = player.Name
			playerBtn.BackgroundColor3 = selectedPlayers[player] and Color3.fromRGB(80, 160, 80) or Color3.fromRGB(60, 60, 60)
			playerBtn.BackgroundTransparency = 0.7
			playerBtn.TextColor3 = Color3.new(1, 1, 1)
			playerBtn.Font = Enum.Font.Gotham
			playerBtn.TextSize = 14
			playerBtn.BorderSizePixel = 0
			playerBtn.Parent = playerList
			local btnCorner = Instance.new("UICorner")
			btnCorner.CornerRadius = UDim.new(0, 4)
			btnCorner.Parent = playerBtn
			playerBtn.MouseButton1Click:Connect(function()
				selectedPlayers[player] = not selectedPlayers[player]
				playerBtn.BackgroundColor3 = selectedPlayers[player] and Color3.fromRGB(80, 160, 80) or Color3.fromRGB(60, 60, 60)
				if nameESPEnabled then
					if selectedPlayers[player] and player.Character then
						createNameESPForPlayer(player)
					else
						removeNameESPForPlayer(player)
					end
				end
			end)
			yPos = yPos + 30
		end
	end
	playerList.CanvasSize = UDim2.new(0, 0, 0, yPos)
end

-- Loop speed feature
local loopspeedEnabled = false
local loopspeedConnection = nil

local function setLoopspeedEnabled(state)
	loopspeedEnabled = state
	loopspeedToggle.Text = loopspeedEnabled and "Loopspeed: ON" or "Loopspeed: OFF"
	loopspeedToggle.BackgroundColor3 = loopspeedEnabled and Color3.fromRGB(80, 200, 80) or Color3.fromRGB(80, 80, 200)
	if loopspeedConnection then
		loopspeedConnection:Disconnect()
		loopspeedConnection = nil
	end
	if loopspeedEnabled then
		loopspeedConnection = RunService.Heartbeat:Connect(function()
			local character = LocalPlayer.Character
			if character then
				local humanoid = character:FindFirstChildOfClass("Humanoid")
				if humanoid then
					local speedValue = tonumber(loopspeedInput.Text) or 16
					pcall(function() humanoid.WalkSpeed = speedValue end)
				end
			end
		end)
	else
		-- reset to default
		local character = LocalPlayer.Character
		if character then
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			if humanoid then
				pcall(function() humanoid.WalkSpeed = 16 end)
			end
		end
	end
end

loopspeedToggle.MouseButton1Click:Connect(function()
	setLoopspeedEnabled(not loopspeedEnabled)
end)

loopspeedInput.FocusLost:Connect(function(enterPressed)
	if loopspeedEnabled then setLoopspeedEnabled(true) end
end)

toggleUIButton.MouseButton1Click:Connect(function()
	mainFrame.Visible = not mainFrame.Visible
	toggleUIButton.Text = mainFrame.Visible and "☰ Close Menu" or "☰ Open Menu"
	if mainFrame.Visible then
		updatePlayerList()
	end
end)

closeButton.MouseButton1Click:Connect(function()
	mainFrame.Visible = false
	toggleUIButton.Text = "☰ Open Menu"
end)

-- AUTO HITBOX toggle
autoToggle.MouseButton1Click:Connect(function()
	autoHitboxEnabled = not autoHitboxEnabled
	autoToggle.Text = autoHitboxEnabled and "Auto Hitbox: ON" or "Auto Hitbox: OFF"
	autoToggle.BackgroundColor3 = autoHitboxEnabled and Color3.fromRGB(50, 180, 50) or Color3.fromRGB(180, 50, 50)
	if autoHitboxEnabled then
		local size = tonumber(sizeInput.Text) or DEFAULT_HITBOX_SIZE
		for _, player in pairs(Players:GetPlayers()) do
			if player ~= LocalPlayer then
				applyHeadHitboxToPlayer(player, size)
			end
		end
	else
		-- remove all processed hitboxes
		for player, _ in pairs(processedPlayers) do
			removeHitboxAndESPForPlayer(player)
		end
	end
	statusLabel.Text = "Processing: " .. tableCount(processedPlayers) .. " Players"
end)

removeAllBtn.MouseButton1Click:Connect(function()
	for player, _ in pairs(processedPlayers) do
		removeHitboxAndESPForPlayer(player)
	end
	statusLabel.Text = "Processing: 0 Players"
end)

autoNameESP.MouseButton1Click:Connect(function()
	nameESPEnabled = not nameESPEnabled
	autoNameESP.Text = nameESPEnabled and "Auto ESP Name: ON" or "Auto ESP Name: OFF"
	autoNameESP.BackgroundColor3 = nameESPEnabled and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(50, 150, 200)
	if not nameESPEnabled then
		for player, _ in pairs(playerData) do
			removeNameESPForPlayer(player)
		end
	else
		for player, selected in pairs(selectedPlayers) do
			if selected and player.Character then
				createNameESPForPlayer(player)
			end
		end
	end
end)

refreshBtn.MouseButton1Click:Connect(updatePlayerList)

espNameAllBtn.MouseButton1Click:Connect(function()
	espNameAllState = not espNameAllState
	espNameAllBtn.Text = espNameAllState and "ESP Name All: ON" or "ESP Name All: OFF"
	espNameAllBtn.BackgroundColor3 = espNameAllState and Color3.fromRGB(80, 220, 80) or Color3.fromRGB(80, 200, 80)
	for _, player in pairs(Players:GetPlayers()) do
		if player ~= LocalPlayer then
			selectedPlayers[player] = espNameAllState
			if espNameAllState and player.Character then
				createNameESPForPlayer(player)
			else
				removeNameESPForPlayer(player)
			end
		end
	end
	updatePlayerList()
end)

boxESPBtn.MouseButton1Click:Connect(function()
	boxESPEnabled = not boxESPEnabled
	boxESPBtn.Text = boxESPEnabled and "ESP Box Charm: ON" or "ESP Box Charm: OFF"
	boxESPBtn.BackgroundColor3 = boxESPEnabled and Color3.fromRGB(220, 220, 80) or Color3.fromRGB(200, 200, 80)
	local size = tonumber(sizeInput.Text) or DEFAULT_HITBOX_SIZE
	for _, player in pairs(Players:GetPlayers()) do
		if player ~= LocalPlayer then
			if boxESPEnabled then
				addBoxESPForPlayer(player, size)
			else
				removeBoxESPForPlayer(player)
			end
		end
	end
end)

-- Invisibility functionality (unchanged logic but robust)
local function toggleInvisibility()
	if not LocalPlayer.Character then
		warn("Character not found")
		return
	end

	isInvisible = not isInvisible
	playInvisSound()

	if isInvisible then
		local humanoidRootPart = getHumanoidRootPart()
		if not humanoidRootPart then
			warn("HumanoidRootPart not found")
			return
		end

		local savedCFrame = humanoidRootPart.CFrame

		-- Move to invisibility position
		LocalPlayer.Character:MoveTo(INVIS_CONFIG.INVISIBILITY_POSITION)
		task.wait(0.15)

		-- Create invisible seat
		local seat = Instance.new("Seat")
		seat.Name = "invischair"
		seat.Anchored = false
		seat.CanCollide = false
		seat.Transparency = 1
		seat.Size = Vector3.new(2, 0.5, 2)
		seat.Position = INVIS_CONFIG.INVISIBILITY_POSITION
		seat.Parent = workspace

		-- Weld seat to HumanoidRootPart
		local weld = Instance.new("Weld")
		weld.Part0 = seat
		weld.Part1 = humanoidRootPart
		weld.Parent = seat

		task.wait()
		seat.CFrame = savedCFrame

		setCharacterTransparency(LocalPlayer.Character, 0.5)

		invisButton.BackgroundColor3 = INVIS_CONFIG.SUCCESS_COLOR
		invisButton.Text = "VISIBLE"

		createNotification("Invisibility ON", "You are now invisible")
	else
		local invisChair = workspace:FindFirstChild("invischair")
		if invisChair then
			invisChair:Destroy()
		end

		if LocalPlayer.Character then
			setCharacterTransparency(LocalPlayer.Character, 0)
		end

		invisButton.BackgroundColor3 = INVIS_CONFIG.PRIMARY_COLOR
		invisButton.Text = "INVISIBLE"

		createNotification("Invisibility OFF", "You are now visible")
	end
end

invisButton.MouseButton1Click:Connect(toggleInvisibility)

UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then return end
	if input.KeyCode == INVIS_CONFIG.TOGGLE_KEY then
		toggleInvisibility()
	end
end)

-- Reset invisibility state on respawn
LocalPlayer.CharacterAdded:Connect(function(character)
	isInvisible = false
	if invisButton then
		invisButton.BackgroundColor3 = INVIS_CONFIG.PRIMARY_COLOR
		invisButton.Text = "INVISIBLE"
	end
	local invisChair = workspace:FindFirstChild("invischair")
	if invisChair then invisChair:Destroy() end
	setCharacterTransparency(character, 0)
end)

-- Player removal cleanup
Players.PlayerRemoving:Connect(function(leavingPlayer)
	if leavingPlayer == LocalPlayer then
		local invisChair = workspace:FindFirstChild("invischair")
		if invisChair then invisChair:Destroy() end
	end
	-- cleanup all data for leaving player
	removeHitboxAndESPForPlayer(leavingPlayer)
end)

-- Player added: setup lifecycle handlers and apply features if needed
Players.PlayerAdded:Connect(function(player)
	-- ensure setup for new player
	setupPlayerLifecycle(player)
	if espNameAllState then
		selectedPlayers[player] = true
		if player.Character then createNameESPForPlayer(player) end
	end
end)

-- Initialize existing players
for _, player in pairs(Players:GetPlayers()) do
	if player ~= LocalPlayer then
		setupPlayerLifecycle(player)
	end
end

-- Periodic auto-apply loop: ensures everyone is checked & hitbox applied when auto enabled
task.spawn(function()
	while true do
		task.wait(5)
		if autoHitboxEnabled then
			local size = tonumber(sizeInput.Text) or DEFAULT_HITBOX_SIZE
			for _, player in pairs(Players:GetPlayers()) do
				if player ~= LocalPlayer and player.Character and not processedPlayers[player] then
					applyHeadHitboxToPlayer(player, size)
				end
			end
			statusLabel.Text = "Processing: " .. tableCount(processedPlayers) .. " Players"
		else
			-- keep status label updated
			statusLabel.Text = "Processing: " .. tableCount(processedPlayers) .. " Players"
		end
	end
end)

-- Keep UI list updated on changes
Players.PlayerAdded:Connect(function()
	updatePlayerList()
end)
Players.PlayerRemoving:Connect(function()
	updatePlayerList()
end)

-- initial UI update and status
statusLabel.Text = "Processing: " .. tableCount(processedPlayers) .. " Players"
updatePlayerList()