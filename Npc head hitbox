
--===== SERVICES =====--
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")

local LocalPlayer = Players.LocalPlayer

--===== CONFIG =====--
local DEFAULT_HITBOX_SIZE = 4

-- Colors (light blue theme)
local COLOR_PRIMARY   = Color3.fromRGB(140, 185, 255) -- buttons base
local COLOR_PRIMARY_D = Color3.fromRGB(100, 150, 255) -- darker
local COLOR_ACCENT    = Color3.fromRGB(180, 220, 255) -- strokes/hover
local COLOR_FRAME     = Color3.fromRGB(40, 60, 100)
local COLOR_TITLE     = Color3.fromRGB(30, 50, 90)
local COLOR_INPUT     = Color3.fromRGB(60, 90, 140)
local COLOR_TEXT      = Color3.fromRGB(255, 255, 255)
local COLOR_DANGER    = Color3.fromRGB(200, 80, 80)
local COLOR_GOOD      = Color3.fromRGB(80, 180, 120)

--===== STATE =====--
local processedNPCs = {}     -- [Model] = {connections = {RBXScriptConnection,...}, esp = Instance}
local respawnWatchers = {}   -- [Model] = {RBXScriptConnection,...}
local connections = {}       -- workspace listeners
local autoHitboxEnabled = false

--===== GUI ROOT =====--
local gui = Instance.new("ScreenGui")
gui.Name = "NPC_Hitbox_GUI"
gui.ResetOnSpawn = false
-- keep same parent as original script context
gui.Parent = game.CoreGui

--===== HELPERS =====--
local function disconnectList(list)
	if not list then return end
	for _, c in ipairs(list) do
		pcall(function() c:Disconnect() end)
	end
end

-- create button helper (with hover + press animation)
local function createButton(parent, text, pos, size, baseColor)
	local btn = Instance.new("TextButton")
	btn.AnchorPoint = Vector2.new(0, 0)
	btn.Position = pos
	btn.Size = size or UDim2.fromOffset(220, 32)
	btn.BackgroundColor3 = baseColor or COLOR_PRIMARY
	btn.Text = text
	btn.TextColor3 = COLOR_TEXT
	btn.Font = Enum.Font.GothamBold
	btn.TextSize = 14
	btn.AutoButtonColor = false
	btn.Parent = parent

	local corner = Instance.new("UICorner", btn)
	corner.CornerRadius = UDim.new(0, 8)

	local stroke = Instance.new("UIStroke", btn)
	stroke.Color = COLOR_ACCENT
	stroke.Thickness = 1

	-- hover
	btn.MouseEnter:Connect(function()
		TweenService:Create(btn, TweenInfo.new(0.15), {
			BackgroundColor3 = baseColor:Lerp(COLOR_ACCENT, 0.25)
		}):Play()
	end)
	btn.MouseLeave:Connect(function()
		TweenService:Create(btn, TweenInfo.new(0.15), {
			BackgroundColor3 = baseColor
		}):Play()
	end)

	-- click "press" animation (uses original size)
	local origSize = btn.Size
	btn.MouseButton1Click:Connect(function()
		local down = TweenService:Create(btn, TweenInfo.new(0.08), {
			Size = UDim2.new(origSize.X.Scale, math.max(0, origSize.X.Offset - 6), origSize.Y.Scale, math.max(0, origSize.Y.Offset - 4))
		})
		local up = TweenService:Create(btn, TweenInfo.new(0.08), {
			Size = origSize
		})
		down:Play()
		down.Completed:Wait()
		up:Play()
	end)

	return btn
end

-- Custom draggable for ANY GuiObject (works better than .Draggable)
local function makeDraggable(guiObject)
	local dragging = false
	local dragStart, startPos

	local function update(input)
		local delta = input.Position - dragStart
		guiObject.Position = UDim2.new(
			startPos.X.Scale, startPos.X.Offset + delta.X,
			startPos.Y.Scale, startPos.Y.Offset + delta.Y
		)
	end

	guiObject.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			dragStart = input.Position
			startPos = guiObject.Position
			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
				end
			end)
		end
	end)

	guiObject.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			if dragging then update(input) end
		end
	end)
end

--===== MAIN PANEL =====--
local frame = Instance.new("Frame")
frame.Name = "Panel"
frame.Position = UDim2.fromOffset(20, 80)
frame.Size = UDim2.fromOffset(300, 230)
frame.BackgroundColor3 = COLOR_FRAME
frame.Visible = false
frame.Active = true
frame.Parent = gui

Instance.new("UICorner", frame).CornerRadius = UDim.new(0, 12)
local frameStroke = Instance.new("UIStroke", frame)
frameStroke.Color = COLOR_ACCENT
frameStroke.Thickness = 2
makeDraggable(frame)

-- Title bar
local title = Instance.new("TextLabel")
title.Size = UDim2.fromOffset(300, 36)
title.BackgroundColor3 = COLOR_TITLE
title.Text = "ðŸŒŒ NPC Head Hitbox Manager"
title.TextColor3 = Color3.fromRGB(220, 240, 255)
title.Font = Enum.Font.GothamBold
title.TextSize = 16
title.Parent = frame
Instance.new("UICorner", title).CornerRadius = UDim.new(0, 12)

-- Size input
local sizeInput = Instance.new("TextBox")
sizeInput.Position = UDim2.fromOffset(20, 50)
sizeInput.Size = UDim2.fromOffset(260, 32)
sizeInput.PlaceholderText = "Size (e.g. 4)"
sizeInput.Text = tostring(DEFAULT_HITBOX_SIZE)
sizeInput.BackgroundColor3 = COLOR_INPUT
sizeInput.TextColor3 = COLOR_TEXT
sizeInput.Font = Enum.Font.Gotham
sizeInput.TextSize = 14
sizeInput.ClearTextOnFocus = false
sizeInput.Parent = frame
Instance.new("UICorner", sizeInput).CornerRadius = UDim.new(0, 8)

-- Buttons
local autoToggle = createButton(frame, "Auto Hitbox: OFF", UDim2.fromOffset(20, 95), UDim2.fromOffset(260, 32), COLOR_PRIMARY_D)
local removeAllBtn = createButton(frame, "Remove All Hitboxes", UDim2.fromOffset(20, 135), UDim2.fromOffset(260, 32), COLOR_DANGER)

-- Status
local statusLabel = Instance.new("TextLabel")
statusLabel.Position = UDim2.fromOffset(14, 180)
statusLabel.Size = UDim2.fromOffset(272, 24)
statusLabel.BackgroundTransparency = 1
statusLabel.Text = "Processing: 0 NPCs"
statusLabel.TextColor3 = Color3.fromRGB(180, 255, 200)
statusLabel.Font = Enum.Font.Gotham
statusLabel.TextSize = 14
statusLabel.TextXAlignment = Enum.TextXAlignment.Left
statusLabel.Parent = frame

local function flashStatus(ok, msg)
	statusLabel.Text = msg
	TweenService:Create(statusLabel, TweenInfo.new(0.1), {
		TextColor3 = ok and Color3.fromRGB(190, 255, 210) or Color3.fromRGB(255, 200, 200)
	}):Play()
	task.delay(0.5, function()
		TweenService:Create(statusLabel, TweenInfo.new(0.3), {
			TextColor3 = Color3.fromRGB(180, 255, 200)
		}):Play()
	end)
end

--===== FLOATING TOGGLE BUTTON (draggable) =====--
local toggleBtn = createButton(gui, "Show Menu", UDim2.fromOffset(20, 20), UDim2.fromOffset(120, 36), COLOR_PRIMARY)
toggleBtn.ZIndex = 10
makeDraggable(toggleBtn)

--===== IMMEDIATE HIDE / RESTORE LOGIC =====--
local isAnimating = false
local storedVisibility = {}

local function hideFrameContentImmediately()
	-- store and hide only GuiObjects (TextLabel, TextButton, TextBox, ImageLabel, etc.)
	storedVisibility = {}
	for _, child in ipairs(frame:GetDescendants()) do
		if child:IsA("GuiObject") and child ~= frame then
			-- save old visibility
			storedVisibility[child] = child.Visible
			-- hide instantly
			child.Visible = false
		end
	end
end

local function restoreFrameContent()
	for child, vis in pairs(storedVisibility) do
		-- restore only if still exists
		if child and child.Parent then
			pcall(function() child.Visible = vis end)
		end
	end
	storedVisibility = {}
end

-- Open/Close panel with tween (slide + instant-hide content)
local function toggleMenu()
	if isAnimating then return end
	isAnimating = true

	if frame.Visible then
		-- closing: hide children immediately so text/buttons disappear at once,
		-- but keep frame visible while animation plays
		hideFrameContentImmediately()
		toggleBtn.Text = "Show Menu"

		local tween = TweenService:Create(frame, TweenInfo.new(0.25), {Size = UDim2.fromOffset(300, 0)})
		tween:Play()
		tween.Completed:Wait()

		-- after tween hide whole frame
		frame.Visible = false
		isAnimating = false
	else
		-- opening: prepare collapsed frame then expand; restore contents AFTER animation
		frame.Size = UDim2.fromOffset(300, 0)
		frame.Visible = true

		local tween = TweenService:Create(frame, TweenInfo.new(0.25), {Size = UDim2.fromOffset(300, 230)})
		tween:Play()
		tween.Completed:Wait()

		-- restore UI content visibility to previous states
		restoreFrameContent()
		toggleBtn.Text = "Hide Menu"
		isAnimating = false
	end
end

toggleBtn.MouseButton1Click:Connect(toggleMenu)

--===== LOGIC (hitbox & esp) =====--
local function updateStatus()
	local count = 0
	for _ in pairs(processedNPCs) do count = count + 1 end
	statusLabel.Text = ("Processing: %d NPCs"):format(count)
end

local function isValidNPC(model)
	if not model or not model:IsA("Model") then return false end
	if model == LocalPlayer.Character then return false end
	if Players:GetPlayerFromCharacter(model) then return false end
	local hum = model:FindFirstChildOfClass("Humanoid")
	local root = model:FindFirstChild("HumanoidRootPart")
	if not hum or not root then return false end
	return true
end

local function addBodyESP(npc)
	if npc:FindFirstChild("NPCBodyESP") then return npc.NPCBodyESP end
	local root = npc:FindFirstChild("HumanoidRootPart")
	if not root then return end

	local box = Instance.new("BoxHandleAdornment")
	box.Name = "NPCBodyESP"
	box.Adornee = root
	box.Size = root.Size + Vector3.new(4, 4, 4)
	box.Color3 = Color3.fromRGB(255, 120, 120)
	box.Transparency = 0.5
	box.ZIndex = 5
	box.AlwaysOnTop = true
	box.Parent = npc
	return box
end

local function removeHeadHitbox(npc)
	if not npc or not processedNPCs[npc] then return end
	local head = npc:FindFirstChild("Head")

	-- disconnect per-NPC connections
	if processedNPCs[npc].connections then
		disconnectList(processedNPCs[npc].connections)
	end

	-- restore head
	if head and head:FindFirstChild("OriginalSize") then
		local originalSize = head.OriginalSize.Value
		head.Size = originalSize
		head.OriginalSize:Destroy()

		head.Massless = false
		head.CanCollide = true
		head.Transparency = 0
		head.Material = Enum.Material.Plastic

		local mesh = head:FindFirstChild("Mesh")
		if mesh then
			mesh.MeshType = Enum.MeshType.Head
			mesh.Scale = Vector3.new(1, 1, 1)
		end
	end

	-- remove ESP
	if processedNPCs[npc].esp then
		processedNPCs[npc].esp:Destroy()
	end

	processedNPCs[npc] = nil
	updateStatus()
end

local function applyHeadHitbox(npc, size)
	if not isValidNPC(npc) then return end
	if processedNPCs[npc] then return end
	if respawnWatchers[npc] then
		disconnectList(respawnWatchers[npc])
		respawnWatchers[npc] = nil
	end

	local head = npc:FindFirstChild("Head")
	local root = npc:FindFirstChild("HumanoidRootPart")
	local hum  = npc:FindFirstChildOfClass("Humanoid")

	-- fake head if missing
	if not head and root then
		head = Instance.new("Part")
		head.Name = "Head"
		head.Size = Vector3.new(2, 1, 1)
		head.CFrame = root.CFrame * CFrame.new(0, root.Size.Y/2 + 1, 0)
		head.Anchored = false
		head.CanCollide = false
		head.Massless = true
		head.Transparency = 1
		head.Parent = npc

		local weld = Instance.new("WeldConstraint")
		weld.Part0 = root
		weld.Part1 = head
		weld.Parent = head
	end

	if not head then return end
	if hum and hum.Health and hum.Health <= 0 then return end

	-- ensure mesh + original size
	if not head:FindFirstChild("Mesh") then
		local mesh = Instance.new("SpecialMesh")
		mesh.MeshType = Enum.MeshType.Head
		mesh.Scale = Vector3.new(1, 1, 1)
		mesh.Name = "Mesh"
		mesh.Parent = head
	end

	if not head:FindFirstChild("OriginalSize") then
		local original = Instance.new("Vector3Value")
		original.Name = "OriginalSize"
		original.Value = head.Size
		original.Parent = head
	end

	-- apply big head
	head.Massless = true
	head.Size = Vector3.new(size, size, size)
	head.CanCollide = false
	head.Transparency = 0.7
	head.Material = Enum.Material.ForceField

	local npcConns = {}
	table.insert(npcConns, head:GetPropertyChangedSignal("Size"):Connect(function()
		if processedNPCs[npc] then
			local wanted = Vector3.new(size, size, size)
			if head.Size ~= wanted then
				head.Size = wanted
			end
		end
	end))

	if hum then
		table.insert(npcConns, hum.Died:Connect(function()
			removeHeadHitbox(npc)
		end))
	end

	local esp = addBodyESP(npc)
	processedNPCs[npc] = {connections = npcConns, esp = esp}
	updateStatus()
end

local function scanWorkspace()
	local size = tonumber(sizeInput.Text) or DEFAULT_HITBOX_SIZE
	for _, v in ipairs(workspace:GetDescendants()) do
		if isValidNPC(v) then
			applyHeadHitbox(v, size)
		end
	end
end

local function tryApplyModel(model)
	task.delay(0.2, function()
		if isValidNPC(model) then
			local size = tonumber(sizeInput.Text) or DEFAULT_HITBOX_SIZE
			applyHeadHitbox(model, size)
		end
	end)
end

local function clearAll()
	for npc, _ in pairs(processedNPCs) do
		removeHeadHitbox(npc)
	end
	for npc, conns in pairs(respawnWatchers) do
		disconnectList(conns)
		respawnWatchers[npc] = nil
	end
	flashStatus(true, "Cleared all.")
end

--===== BUTTON EVENTS =====--
autoToggle.MouseButton1Click:Connect(function()
	autoHitboxEnabled = not autoHitboxEnabled
	autoToggle.Text = autoHitboxEnabled and "Auto Hitbox: ON" or "Auto Hitbox: OFF"
	autoToggle.BackgroundColor3 = autoHitboxEnabled and COLOR_GOOD or COLOR_PRIMARY_D

	-- remove old listeners
	for _, conn in ipairs(connections) do pcall(function() conn:Disconnect() end) end
	table.clear(connections)

	if autoHitboxEnabled then
		flashStatus(true, "Auto ON â†’ Scanning...")
		scanWorkspace()
		table.insert(connections, workspace.DescendantAdded:Connect(function(desc)
			local model = desc:FindFirstAncestorOfClass("Model")
			if model then tryApplyModel(model) end
		end))
		table.insert(connections, workspace.ChildAdded:Connect(function(child)
			if child:IsA("Model") then tryApplyModel(child) end
		end))
	else
		flashStatus(false, "Auto OFF")
	end
end)

removeAllBtn.MouseButton1Click:Connect(function()
	clearAll()
end)

-- Toggle panel by keyboard (F4) â€” respects animation/debounce
UserInputService.InputBegan:Connect(function(input, gpe)
	if gpe then return end
	if input.KeyCode == Enum.KeyCode.F4 then
		toggleMenu()
	end
end)

--===== PLAYER RELOAD =====--
LocalPlayer.CharacterAdded:Connect(function()
	task.wait(2)
	if autoHitboxEnabled then scanWorkspace() end
end)
