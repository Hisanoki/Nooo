-- Combined Head Hitbox & Invisibility GUI (Mobile Tab Version)
-- Rewritten and hardened:
--  - Robust apply/remove lifecycle for hitboxes
--  - Ensures hitboxes are removed immediately when the target dies (avoid applying to corpse)
--  - Prevents re-applying to dead/ragdoll characters
--  - Better connection bookkeeping to avoid stale listeners

-- Lưu ý: logic chính vẫn tương tự file gốc, nhưng tập trung vào
-- việc dọn dẹp khi Humanoid chết để tránh "cản" bắn xuyên qua xác.

-- SERVICES
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer

-- CONFIG
local DEFAULT_HITBOX_SIZE = 4
local ESP_COLOR = Color3.fromRGB(255, 150, 150)
local ESP_TRANSPARENCY = 0.7
local TEXT_ESP_COLOR = Color3.fromRGB(255, 255, 255)

local INVIS_CONFIG = {
	TOGGLE_KEY = Enum.KeyCode.X,
	SOUND_ID = "rbxassetid://942127495",
	INVISIBILITY_POSITION = Vector3.new(-25.95, 84, 3537.55),
	NOTIFICATION_DURATION = 3,
	BACKGROUND_COLOR = Color3.fromRGB(25, 25, 25),
	PRIMARY_COLOR = Color3.fromRGB(0, 170, 255),
	SUCCESS_COLOR = Color3.fromRGB(46, 204, 113),
	TEXT_COLOR = Color3.fromRGB(255, 255, 255),
}

-- STATE
local autoHitboxEnabled = false
local nameESPEnabled = false
local boxESPEnabled = false
local selectedPlayers = {}
local globalConnections = {}

-- Improved hitbox tracking:
-- keyed by Player (not character) to make cleanup and reapply easier
-- hitboxData[player] = {
--   applied = bool,
--   backups = {...},
--   connections = {conn1, conn2, ...},
--   adornment = instance,
--   lastDeath = os.time() or tick(),
-- }
local hitboxData = {}

-- Helper functions
local function tableCount(t)
	local count = 0
	for _ in pairs(t) do
		count = count + 1
	end
	return count
end

local function getTeamColor(player)
	if player and player.Team and player.Team.TeamColor then
		return player.Team.TeamColor.Color
	end
	return ESP_COLOR
end

local function createNotification(title, text)
	StarterGui:SetCore("SendNotification", {
		Title = title,
		Text = text,
		Duration = INVIS_CONFIG.NOTIFICATION_DURATION,
	})
end

local function setCharacterTransparency(character, transparency)
	if not character then return end
	for _, descendant in ipairs(character:GetDescendants()) do
		if descendant:IsA("BasePart") or descendant:IsA("Decal") then
			descendant.Transparency = transparency
		end
	end
end

local function getHumanoidRootPart()
	local character = LocalPlayer.Character
	if not character then return nil end
	return character:FindFirstChild("HumanoidRootPart")
end

local invisSound
local function playInvisSound()
	if invisSound then
		pcall(function() invisSound:Play() end)
	end
end

local isInvisible = false
local invisButton

local function toggleInvisibility()
	if not LocalPlayer.Character then
		warn("Character not found")
		return
	end

	isInvisible = not isInvisible
	playInvisSound()

	if isInvisible then
		local humanoidRootPart = getHumanoidRootPart()
		if not humanoidRootPart then
			warn("HumanoidRootPart not found")
			return
		end

		local savedCFrame = humanoidRootPart.CFrame

		-- Move to configured invis position first
		LocalPlayer.Character:MoveTo(INVIS_CONFIG.INVISIBILITY_POSITION)
		task.wait(0.15)

		-- Create an invisible seat and weld to HumanoidRootPart
		local seat = Instance.new("Seat")
		seat.Name = "invischair"
		seat.Anchored = false
		seat.CanCollide = false
		seat.Transparency = 1
		seat.Size = Vector3.new(2, 0.5, 2)
		seat.Position = INVIS_CONFIG.INVISIBILITY_POSITION
		seat.Parent = workspace

		local weld = Instance.new("Weld")
		weld.Part0 = seat
		weld.Part1 = humanoidRootPart
		weld.Parent = seat

		task.wait()
		seat.CFrame = savedCFrame

		setCharacterTransparency(LocalPlayer.Character, 0.5)

		invisButton.BackgroundColor3 = INVIS_CONFIG.SUCCESS_COLOR
		invisButton.Text = "VISIBLE"

		createNotification("Invisibility ON", "You are now invisible")
	else
		local invisChair = workspace:FindFirstChild("invischair")
		if invisChair then
			invisChair:Destroy()
		end

		if LocalPlayer.Character then
			setCharacterTransparency(LocalPlayer.Character, 0)
		end

		invisButton.BackgroundColor3 = INVIS_CONFIG.PRIMARY_COLOR
		invisButton.Text = "INVISIBLE"

		createNotification("Invisibility OFF", "You are now visible")
	end
end

-- Utility: check if character is alive (Humanoid exists and is not dead)
local function isCharacterAlive(character)
	if not character then return false end
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if not humanoid then return false end
	-- Health check and State check to avoid ragdoll/dead
	if humanoid.Health <= 0 then
		return false
	end
	-- HumanoidStateType might be "Dead"
	local success, state = pcall(function() return humanoid:GetState() end)
	if success and state == Enum.HumanoidStateType.Dead then
		return false
	end
	return true
end

-- Robust removal that attempts to restore everything and ensure no leftover blocking parts.
local function removeHeadHitboxForPlayer(player)
	if not player then return end
	local data = hitboxData[player]
	if not data then return end

	-- mark not applied
	data.applied = false

	-- Disconnect stored connections
	if data.connections then
		for _, conn in ipairs(data.connections) do
			if conn and (conn.Disconnect or conn.disconnect) then
				pcall(function()
					if conn.Disconnect then conn:Disconnect()
					elseif conn.disconnect then conn:disconnect()
					end
				end)
			end
		end
		data.connections = {}
	end

	-- Restore head from character if present
	local character = player.Character
	if character then
		local head = character:FindFirstChild("Head")
		if head and head:IsA("BasePart") and data.backups then
			-- Restore size
			if data.backups.originalSize then
				pcall(function() head.Size = data.backups.originalSize end)
			end
			-- Restore Mesh(es)
			if data.backups.meshes and type(data.backups.meshes) == "table" then
				for _, meshInfo in ipairs(data.backups.meshes) do
					if meshInfo and meshInfo.instance and meshInfo.instance.Parent == nil and head then
						pcall(function() meshInfo.instance.Parent = head end)
					end
				end
			end
			-- Restore other properties
			if data.backups.transparency ~= nil then
				pcall(function() head.Transparency = data.backups.transparency end)
			end
			if data.backups.canCollide ~= nil then
				pcall(function() head.CanCollide = data.backups.canCollide end)
			end
			if data.backups.massless ~= nil then
				pcall(function() head.Massless = data.backups.massless end)
			end
			if data.backups.material then
				pcall(function() head.Material = data.backups.material end)
			end
		end
	end

	-- Remove adornment if any
	if data.adornment and data.adornment.Parent then
		pcall(function() data.adornment:Destroy() end)
	end

	-- Clear backups
	data.backups = {}

	-- Clear lastDeath stays as is (useful to block immediate reapply)
	-- Remove entry entirely to avoid stale references
	hitboxData[player] = nil
end

-- Apply head hitbox for a player. Will NOT apply if target is dead/ragdoll.
local function applyHeadHitboxForPlayer(player, size)
	-- Do not apply to local player
	if player == LocalPlayer then return end
	if not player or not player:IsA("Player") then return end

	-- Ensure size is valid
	local sizeVal = tonumber(size) or DEFAULT_HITBOX_SIZE
	if sizeVal <= 0 then sizeVal = DEFAULT_HITBOX_SIZE end

	-- Ensure we have data object
	hitboxData[player] = hitboxData[player] or {applied = false, backups = {}, connections = {}, adornment = nil, lastDeath = 0}

	-- If already applied, update size/adornment instead
	local existing = hitboxData[player]
	if existing and existing.applied then
		-- Update any existing adornment's size if present
		if existing.adornment and existing.adornment.Adornee and existing.adornment:IsA("BoxHandleAdornment") then
			pcall(function()
				existing.adornment.Size = Vector3.new(sizeVal, sizeVal, sizeVal)
			end)
		end
		-- If head is present, update head size (but only if alive)
		if player.Character and isCharacterAlive(player.Character) then
			local head = player.Character:FindFirstChild("Head")
			if head and head:IsA("BasePart") then
				pcall(function()
					head.Size = Vector3.new(sizeVal, sizeVal, sizeVal)
				end)
			end
		end
		return
	end

	-- Wait for character and head
	local character = player.Character
	if not character then
		-- Defer application until character spawns
		local conn
		conn = player.CharacterAdded:Connect(function(char)
			if conn then
				pcall(function() conn:Disconnect() end)
			end
			-- small delay to allow character to initialize
			task.wait(0.2)
			applyHeadHitboxForPlayer(player, sizeVal)
		end)
		table.insert(hitboxData[player].connections, conn)
		return
	end

	-- Wait for Humanoid and ensure alive
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if not humanoid then
		-- Wait for humanoid to exist before applying
		local hConn
		hConn = character.ChildAdded:Connect(function(child)
			if child:IsA("Humanoid") then
				if hConn then pcall(function() hConn:Disconnect() end) end
				-- give it a tiny moment to initialize
				task.wait(0.1)
				applyHeadHitboxForPlayer(player, sizeVal)
			end
		end)
		table.insert(hitboxData[player].connections, hConn)
		return
	end

	-- If humanoid dead or health <= 0, don't apply. Also block immediate reapply after death using lastDeath timestamp.
	if humanoid.Health <= 0 or humanoid:GetState() == Enum.HumanoidStateType.Dead then
		-- record time to prevent immediate reapply
		hitboxData[player].lastDeath = tick()
		return
	end

	-- Ensure head exists
	local head = character:FindFirstChild("Head")
	if not head or not head:IsA("BasePart") then
		-- If head isn't available yet, listen for it
		local charConn
		charConn = character.ChildAdded:Connect(function(child)
			if child.Name == "Head" and child:IsA("BasePart") then
				if charConn then pcall(function() charConn:Disconnect() end) end
				-- small delay then apply
				task.wait(0.05)
				applyHeadHitboxForPlayer(player, sizeVal)
			end
		end)
		table.insert(hitboxData[player].connections, charConn)
		return
	end

	-- Prevent reapplying too soon after death (corpse lingering)
	local lastDeath = hitboxData[player].lastDeath or 0
	if tick() - lastDeath < 0.8 then
		-- too soon after death -> skip applying to avoid corpse interference
		return
	end

	-- Backup properties safely
	local backups = {}
	backups.originalSize = head.Size
	backups.transparency = head.Transparency
	backups.canCollide = head.CanCollide
	backups.massless = head.Massless
	backups.material = head.Material
	-- Backup meshes (SpecialMesh/BlockMesh/Mesh)
	backups.meshes = {}
	for _, child in ipairs(head:GetChildren()) do
		if child:IsA("Mesh") or child:IsA("SpecialMesh") or child:IsA("BlockMesh") then
			local clone = child:Clone()
			clone.Parent = nil
			table.insert(backups.meshes, {name = child.Name, instance = clone})
			-- remove original to avoid visual conflict
			pcall(function() child:Destroy() end)
		end
	end

	-- Apply hitbox only if humanoid is still alive (race condition guard)
	if not isCharacterAlive(character) then
		hitboxData[player].lastDeath = tick()
		return
	end

	-- Apply properties (these affect hit detection; so we must restore on death immediately)
	pcall(function()
		head.Massless = true
		head.Size = Vector3.new(sizeVal, sizeVal, sizeVal)
		head.CanCollide = false -- keep non-collidable so physics isn't affected
		head.Transparency = 0.5
		head.Material = Enum.Material.ForceField
	end)

	-- Visible adornment for debugging / ESP (doesn't affect physics)
	local adorn = Instance.new("BoxHandleAdornment")
	adorn.Name = "HeadHitboxAdornment"
	adorn.Adornee = head
	adorn.Size = Vector3.new(sizeVal, sizeVal, sizeVal)
	adorn.Color3 = ESP_COLOR
	adorn.Transparency = ESP_TRANSPARENCY
	adorn.ZIndex = 10
	adorn.AlwaysOnTop = true
	adorn.Parent = head

	-- Store backups and adornment
	hitboxData[player].backups = backups
	hitboxData[player].adornment = adorn
	hitboxData[player].applied = true

	-- Connect to humanoid died to cleanup IMMEDIATELY (this prevents hitbox remaining on corpse)
	local diedConn
	diedConn = humanoid.Died:Connect(function()
		-- record death time
		hitboxData[player].lastDeath = tick()
		-- immediate removal
		removeHeadHitboxForPlayer(player)
		-- safety: disconnect diedConn if present
		if diedConn then
			pcall(function() diedConn:Disconnect() end)
		end
	end)
	table.insert(hitboxData[player].connections, diedConn)

	-- Also observe Humanoid.StateChanged: some games set ragdoll/other states where Health not yet zero
	local stateConn
	stateConn = humanoid.StateChanged:Connect(function(old, new)
		if new == Enum.HumanoidStateType.Dead then
			hitboxData[player].lastDeath = tick()
			removeHeadHitboxForPlayer(player)
		end
	end)
	table.insert(hitboxData[player].connections, stateConn)

	-- CharacterRemoving: cleanup before respawn/leave
	local charRemovingConn = player.CharacterRemoving:Connect(function()
		removeHeadHitboxForPlayer(player)
	end)
	table.insert(hitboxData[player].connections, charRemovingConn)

	-- PlayerRemoving: cleanup final
	local playerRemovingConn
	playerRemovingConn = Players.PlayerRemoving:Connect(function(removing)
		if removing == player then
			removeHeadHitboxForPlayer(player)
			if playerRemovingConn then
				pcall(function() playerRemovingConn:Disconnect() end)
			end
		end
	end)
	table.insert(hitboxData[player].connections, playerRemovingConn)
end

-- UI helper functions (transparent button/input/label)
local function createTransparentButton(text, color, parent)
	local btn = Instance.new("TextButton")
	btn.Size = UDim2.new(1, 0, 0, 32)
	btn.Text = text
	btn.BackgroundColor3 = color
	btn.BackgroundTransparency = 0.7
	btn.TextColor3 = Color3.new(1, 1, 1)
	btn.Font = Enum.Font.Gotham
	btn.TextSize = 14
	btn.BorderSizePixel = 0
	btn.Parent = parent
	local btnCorner = Instance.new("UICorner")
	btnCorner.CornerRadius = UDim.new(0, 4)
	btnCorner.Parent = btn
	return btn
end

local function createTransparentInput(placeholder, text, parent)
	local input = Instance.new("TextBox")
	input.Size = UDim2.new(1, 0, 0, 32)
	input.PlaceholderText = placeholder
	input.Text = text
	input.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
	input.BackgroundTransparency = 0.7
	input.TextColor3 = Color3.new(1, 1, 1)
	input.Font = Enum.Font.Gotham
	input.TextSize = 14
	input.BorderSizePixel = 0
	input.Parent = parent
	local inputCorner = Instance.new("UICorner")
	inputCorner.CornerRadius = UDim.new(0, 4)
	inputCorner.Parent = input
	return input
end

local function createTransparentLabel(text, parent)
	local label = Instance.new("TextLabel")
	label.Size = UDim2.new(1, 0, 0, 22)
	label.BackgroundTransparency = 1
	label.Text = text
	label.TextColor3 = Color3.fromRGB(200, 200, 200)
	label.Font = Enum.Font.Gotham
	label.TextSize = 12
	label.TextXAlignment = Enum.TextXAlignment.Left
	label.Parent = parent
	return label
end

-- UI SETUP (Mobile size)
local gui = Instance.new("ScreenGui")
gui.Name = "Mobile_ESP_GUI"
gui.ResetOnSpawn = false
gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
gui.Parent = LocalPlayer:WaitForChild("PlayerGui")

local mainContainer = Instance.new("Frame")
mainContainer.Size = UDim2.new(0, 220, 0, 36)
mainContainer.Position = UDim2.new(0.5, -110, 0, 10)
mainContainer.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
mainContainer.BackgroundTransparency = 0.7
mainContainer.BorderSizePixel = 0
mainContainer.Active = true
mainContainer.Draggable = true
mainContainer.Parent = gui
local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0, 8)
corner.Parent = mainContainer

local toggleUIButton = Instance.new("TextButton")
toggleUIButton.Size = UDim2.new(0, 110, 0, 28)
toggleUIButton.Position = UDim2.new(0.5, -55, 0.5, -14)
toggleUIButton.Text = "☰ Open Menu"
toggleUIButton.TextColor3 = Color3.fromRGB(255, 255, 255)
toggleUIButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
toggleUIButton.BackgroundTransparency = 0.7
toggleUIButton.BorderSizePixel = 0
toggleUIButton.Font = Enum.Font.Gotham
toggleUIButton.TextSize = 14
toggleUIButton.Parent = mainContainer
local buttonCorner = Instance.new("UICorner")
buttonCorner.CornerRadius = UDim.new(0, 6)
buttonCorner.Parent = toggleUIButton

local mainFrame = Instance.new("Frame")
mainFrame.Size = UDim2.new(0, 220, 0, 320)
mainFrame.Position = UDim2.new(0.5, -110, 0.5, -160)
mainFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
mainFrame.BackgroundTransparency = 0.7
mainFrame.BorderSizePixel = 0
mainFrame.Visible = false
mainFrame.Active = true
mainFrame.Draggable = true
mainFrame.Parent = gui
local mainCorner = Instance.new("UICorner")
mainCorner.CornerRadius = UDim.new(0, 8)
mainCorner.Parent = mainFrame

-- Tab Bar
local tabBar = Instance.new("Frame")
tabBar.Size = UDim2.new(1, 0, 0, 32)
tabBar.Position = UDim2.new(0, 0, 0, 0)
tabBar.BackgroundTransparency = 1
tabBar.Parent = mainFrame

local tab1Btn = Instance.new("TextButton")
tab1Btn.Size = UDim2.new(0.5, -2, 1, 0)
tab1Btn.Position = UDim2.new(0, 0, 0, 0)
tab1Btn.Text = "HeadHitbox"
tab1Btn.TextColor3 = Color3.fromRGB(255, 255, 255)
tab1Btn.BackgroundColor3 = Color3.fromRGB(220, 60, 60)
tab1Btn.BackgroundTransparency = 0.2
tab1Btn.Font = Enum.Font.GothamBold
tab1Btn.TextSize = 14
tab1Btn.BorderSizePixel = 0
tab1Btn.Parent = tabBar
local tab1Corner = Instance.new("UICorner")
tab1Corner.CornerRadius = UDim.new(0, 6)
tab1Corner.Parent = tab1Btn

local tab2Btn = Instance.new("TextButton")
tab2Btn.Size = UDim2.new(0.5, -2, 1, 0)
tab2Btn.Position = UDim2.new(0.5, 2, 0, 0)
tab2Btn.Text = "Other"
tab2Btn.TextColor3 = Color3.fromRGB(255, 255, 255)
tab2Btn.BackgroundColor3 = Color3.fromRGB(60, 120, 220)
tab2Btn.BackgroundTransparency = 0.2
tab2Btn.Font = Enum.Font.GothamBold
tab2Btn.TextSize = 14
tab2Btn.BorderSizePixel = 0
tab2Btn.Parent = tabBar
local tab2Corner = Instance.new("UICorner")
tab2Corner.CornerRadius = UDim.new(0, 6)
tab2Corner.Parent = tab2Btn

-- Tab Panels
local leftPanel = Instance.new("Frame")
leftPanel.Size = UDim2.new(1, -12, 1, -44)
leftPanel.Position = UDim2.new(0, 6, 0, 38)
leftPanel.BackgroundTransparency = 1
leftPanel.BorderSizePixel = 0
leftPanel.Visible = true
leftPanel.Parent = mainFrame

local rightPanel = Instance.new("ScrollingFrame")
rightPanel.Size = UDim2.new(1, -12, 1, -44)
rightPanel.Position = UDim2.new(0, 6, 0, 38)
rightPanel.BackgroundTransparency = 1
rightPanel.BorderSizePixel = 0
rightPanel.ScrollBarThickness = 4
rightPanel.CanvasSize = UDim2.new(0, 0, 0, 0)
rightPanel.Visible = false
rightPanel.Parent = mainFrame

-- UIListLayouts
local leftLayout = Instance.new("UIListLayout")
leftLayout.Parent = leftPanel
leftLayout.SortOrder = Enum.SortOrder.LayoutOrder
leftLayout.Padding = UDim.new(0, 4)

local rightLayout = Instance.new("UIListLayout")
rightLayout.Parent = rightPanel
rightLayout.SortOrder = Enum.SortOrder.LayoutOrder
rightLayout.Padding = UDim.new(0, 4)

-- HeadHitbox Tab (leftPanel)
local leftTitle = createTransparentLabel("Head hitbox", leftPanel)
leftTitle.TextColor3 = Color3.fromRGB(255, 150, 150)
leftTitle.Font = Enum.Font.GothamBold
leftTitle.TextSize = 14

local sizeInput = createTransparentInput("Size (e.g. 4)", tostring(DEFAULT_HITBOX_SIZE), leftPanel)
local autoToggle = createTransparentButton("Auto Hitbox: OFF", Color3.fromRGB(180, 50, 50), leftPanel)
local removeAllBtn = createTransparentButton("Remove All Hitboxes", Color3.fromRGB(180, 50, 50), leftPanel)
local statusLabel = createTransparentLabel("Processing: 0 Players", leftPanel)
local loopspeedLabel = createTransparentLabel("Loopspeed", leftPanel)
local loopspeedInput = createTransparentInput("Speed (e.g. 16)", "16", leftPanel)
local loopspeedToggle = createTransparentButton("Loopspeed: OFF", Color3.fromRGB(80, 80, 200), leftPanel)
invisButton = createTransparentButton("INVISIBLE", INVIS_CONFIG.PRIMARY_COLOR, leftPanel)

-- Sound for invisibility toggle
invisSound = Instance.new("Sound")
invisSound.Name = "ToggleSound"
invisSound.SoundId = INVIS_CONFIG.SOUND_ID
invisSound.Volume = 0.5
invisSound.Parent = gui

-- Other Tab (rightPanel)
local rightTitle = createTransparentLabel("ESP & Other Features", rightPanel)
rightTitle.TextColor3 = Color3.fromRGB(150, 200, 255)
rightTitle.Font = Enum.Font.GothamBold
rightTitle.TextSize = 14

local playerList = Instance.new("ScrollingFrame")
playerList.Size = UDim2.new(1, 0, 0, 110)
playerList.BackgroundTransparency = 1
playerList.BorderSizePixel = 0
playerList.ScrollBarThickness = 4
playerList.CanvasSize = UDim2.new(0, 0, 0, 0)
playerList.Parent = rightPanel
local playerListLayout = Instance.new("UIListLayout")
playerListLayout.Parent = playerList
playerListLayout.SortOrder = Enum.SortOrder.LayoutOrder
playerListLayout.Padding = UDim.new(0, 2)

local autoNameESP = createTransparentButton("Auto ESP Name: OFF", Color3.fromRGB(50, 150, 200), rightPanel)
local refreshBtn = createTransparentButton("Refresh Player List", Color3.fromRGB(80, 80, 180), rightPanel)
local espNameAllBtn = createTransparentButton("ESP Name All: OFF", Color3.fromRGB(80, 200, 80), rightPanel)
local boxESPBtn = createTransparentButton("ESP Box Charm: OFF", Color3.fromRGB(200, 200, 80), rightPanel)

-- Tab switching logic
local function switchTab(tabIndex)
	if tabIndex == 1 then
		leftPanel.Visible = true
		rightPanel.Visible = false
		tab1Btn.BackgroundTransparency = 0.2
		tab2Btn.BackgroundTransparency = 0.6
	else
		leftPanel.Visible = false
		rightPanel.Visible = true
		tab1Btn.BackgroundTransparency = 0.6
		tab2Btn.BackgroundTransparency = 0.2
	end
end

tab1Btn.MouseButton1Click:Connect(function() switchTab(1) end)
tab2Btn.MouseButton1Click:Connect(function() switchTab(2) end)
switchTab(1)

-- Close Button
local closeButton = Instance.new("TextButton")
closeButton.Size = UDim2.new(0, 28, 0, 28)
closeButton.Position = UDim2.new(1, -32, 0, 2)
closeButton.Text = "X"
closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
closeButton.BackgroundTransparency = 1
closeButton.BorderSizePixel = 0
closeButton.Font = Enum.Font.GothamBold
closeButton.TextSize = 16
closeButton.Parent = mainFrame

-- ESP Name logic
local nameESPObjects = {}

local function createNameESP(player, char)
	if player == LocalPlayer then return end
	if not char then return end
	local head = char:FindFirstChild("Head")
	if not head then return end
	if nameESPObjects[player] then
		nameESPObjects[player]:Destroy()
		nameESPObjects[player] = nil
	end
	local billboard = Instance.new("BillboardGui")
	billboard.Name = "NameESP"
	billboard.Adornee = head
	billboard.Size = UDim2.new(0, 200, 0, 50)
	billboard.StudsOffset = Vector3.new(0, 2.5, 0)
	billboard.AlwaysOnTop = true
	billboard.MaxDistance = 1000
	billboard.Parent = head
	local nameLabel = Instance.new("TextLabel")
	nameLabel.Size = UDim2.new(1, 0, 0.5, 0)
	nameLabel.Position = UDim2.new(0, 0, 0, 0)
	nameLabel.BackgroundTransparency = 1
	nameLabel.Text = player.Name
	nameLabel.TextColor3 = getTeamColor(player)
	nameLabel.TextStrokeTransparency = 0
	nameLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
	nameLabel.Font = Enum.Font.GothamBold
	nameLabel.TextSize = 14
	nameLabel.Parent = billboard
	local distanceLabel = Instance.new("TextLabel")
	distanceLabel.Size = UDim2.new(1, 0, 0.5, 0)
	distanceLabel.Position = UDim2.new(0, 0, 0.5, 0)
	distanceLabel.BackgroundTransparency = 1
	distanceLabel.Text = "0m"
	distanceLabel.TextColor3 = TEXT_ESP_COLOR
	distanceLabel.TextStrokeTransparency = 0
	distanceLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
	distanceLabel.Font = Enum.Font.Gotham
	distanceLabel.TextSize = 12
	distanceLabel.Parent = billboard
	local connection
	connection = RunService.Heartbeat:Connect(function()
		if not billboard or not billboard.Parent or not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("Head") then
			if connection then
				connection:Disconnect()
			end
			return
		end
		local localHead = LocalPlayer.Character.Head
		local distance = (head.Position - localHead.Position).Magnitude
		distanceLabel.Text = string.format("%.1fm", distance)
		nameLabel.TextColor3 = getTeamColor(player)
	end)
	nameESPObjects[player] = billboard
end

local function removeNameESP(player)
	if nameESPObjects[player] then
		pcall(function() nameESPObjects[player]:Destroy() end)
		nameESPObjects[player] = nil
	end
end

-- Player handling: ensure hitbox apply/remove lifecycle is robust
local function handlePlayer(player)
	-- skip local player
	if player == LocalPlayer then return end

	-- Ensure we prepare a hitboxData entry so we can store connections for cleanup if needed
	hitboxData[player] = hitboxData[player] or {applied = false, backups = {}, connections = {}, adornment = nil, lastDeath = 0}

	-- CharacterAdded: apply hitbox (if auto is enabled) and other features
	local charAddedConn
	charAddedConn = player.CharacterAdded:Connect(function(char)
		-- small delay to ensure parts exist
		task.wait(0.25)
		-- Re-apply hitbox automatically when enabled (but only if alive)
		if autoHitboxEnabled and isCharacterAlive(char) then
			applyHeadHitboxForPlayer(player, tonumber(sizeInput.Text) or DEFAULT_HITBOX_SIZE)
		end
		-- Name ESP handling
		if nameESPEnabled and selectedPlayers[player] then
			createNameESP(player, char)
		end
		-- Box ESP
		if boxESPEnabled then
			local color = getTeamColor(player)
			local size = tonumber(sizeInput.Text) or DEFAULT_HITBOX_SIZE
			local head = char:FindFirstChild("Head")
			if head and head:IsA("BasePart") then
				local existing = head:FindFirstChild("BoxCharmESP")
				if existing then existing:Destroy() end
				local box = Instance.new("BoxHandleAdornment")
				box.Name = "BoxCharmESP"
				box.Adornee = head
				box.Size = Vector3.new(size, size, size)
				box.Color3 = color
				box.Transparency = ESP_TRANSPARENCY
				box.ZIndex = 10
				box.AlwaysOnTop = true
				box.Parent = head
			end
		end
	end)

	table.insert(hitboxData[player].connections, charAddedConn)

	-- CharacterRemoving: ensure cleanup (remove adornments, restore head)
	local charRemovingConn
	charRemovingConn = player.CharacterRemoving:Connect(function()
		-- remove adornments like BoxCharmESP if present
		if player.Character then
			local head = player.Character:FindFirstChild("Head")
			if head then
				local existBox = head:FindFirstChild("BoxCharmESP")
				if existBox then pcall(function() existBox:Destroy() end) end
			end
		end
		-- Remove head hitbox immediately
		removeHeadHitboxForPlayer(player)
		-- Remove name ESP
		removeNameESP(player)
		-- clear selectedPlayers mapping to avoid stale state
		selectedPlayers[player] = nil
	end)
	table.insert(hitboxData[player].connections, charRemovingConn)

	-- PlayerRemoving: ensure final cleanup
	local playerRemovingConn
	playerRemovingConn = Players.PlayerRemoving:Connect(function(removing)
		if removing == player then
			removeHeadHitboxForPlayer(player)
			removeNameESP(player)
			selectedPlayers[player] = nil
			-- disconnect any remaining connections stored
			if hitboxData[player] and hitboxData[player].connections then
				for _, conn in ipairs(hitboxData[player].connections) do
					if conn and (conn.Disconnect or conn.disconnect) then
						pcall(function()
							if conn.Disconnect then conn:Disconnect()
							elseif conn.disconnect then conn:disconnect()
							end
						end)
					end
				end
			end
			hitboxData[player] = nil
			if playerRemovingConn then pcall(function() playerRemovingConn:Disconnect() end) end
		end
	end)
	table.insert(hitboxData[player].connections, playerRemovingConn)

	-- If character already exists when we handle the player, trigger the characterAdded logic manually
	if player.Character then
		task.spawn(function()
			task.wait(0.15)
			if autoHitboxEnabled and isCharacterAlive(player.Character) then
				applyHeadHitboxForPlayer(player, tonumber(sizeInput.Text) or DEFAULT_HITBOX_SIZE)
			end
			if nameESPEnabled and selectedPlayers[player] and player.Character then
				createNameESP(player, player.Character)
			end
		end)
	end
end

-- Player list UI and utilities
local function updatePlayerList()
	for _, child in pairs(playerList:GetChildren()) do
		if child:IsA("TextButton") then
			child:Destroy()
		end
	end
	local yPos = 0
	for _, player in pairs(Players:GetPlayers()) do
		if player ~= LocalPlayer then
			local playerBtn = Instance.new("TextButton")
			playerBtn.Size = UDim2.new(1, -6, 0, 28)
			playerBtn.Text = player.Name
			playerBtn.BackgroundColor3 = selectedPlayers[player] and Color3.fromRGB(80, 160, 80) or Color3.fromRGB(60, 60, 60)
			playerBtn.BackgroundTransparency = 0.7
			playerBtn.TextColor3 = Color3.new(1, 1, 1)
			playerBtn.Font = Enum.Font.Gotham
			playerBtn.TextSize = 14
			playerBtn.BorderSizePixel = 0
			playerBtn.Parent = playerList
			local btnCorner = Instance.new("UICorner")
			btnCorner.CornerRadius = UDim.new(0, 4)
			btnCorner.Parent = playerBtn
			playerBtn.MouseButton1Click:Connect(function()
				selectedPlayers[player] = not selectedPlayers[player]
				playerBtn.BackgroundColor3 = selectedPlayers[player] and Color3.fromRGB(80, 160, 80) or Color3.fromRGB(60, 60, 60)
				if nameESPEnabled then
					if selectedPlayers[player] and player.Character then
						createNameESP(player, player.Character)
					else
						removeNameESP(player)
					end
				end
			end)
			yPos = yPos + 30
		end
	end
	playerList.CanvasSize = UDim2.new(0, 0, 0, yPos)
end

-- Loopspeed logic
local loopspeedEnabled = false
local loopspeedConnection = nil

local function setLoopspeedEnabled(state)
	loopspeedEnabled = state
	loopspeedToggle.Text = loopspeedEnabled and "Loopspeed: ON" or "Loopspeed: OFF"
	loopspeedToggle.BackgroundColor3 = loopspeedEnabled and Color3.fromRGB(80, 200, 80) or Color3.fromRGB(80, 80, 200)
	if loopspeedConnection then
		pcall(function() loopspeedConnection:Disconnect() end)
		loopspeedConnection = nil
	end
	if loopspeedEnabled then
		loopspeedConnection = RunService.Heartbeat:Connect(function()
			local character = LocalPlayer.Character
			if character then
				local humanoid = character:FindFirstChildOfClass("Humanoid")
				if humanoid then
					local speedValue = tonumber(loopspeedInput.Text) or 16
					humanoid.WalkSpeed = speedValue
				end
			end
		end)
	else
		local character = LocalPlayer.Character
		if character then
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			if humanoid then
				humanoid.WalkSpeed = 16
			end
		end
	end
end

loopspeedToggle.MouseButton1Click:Connect(function()
	setLoopspeedEnabled(not loopspeedEnabled)
end)

loopspeedInput.FocusLost:Connect(function()
	if loopspeedEnabled then
		setLoopspeedEnabled(true)
	end
end)

toggleUIButton.MouseButton1Click:Connect(function()
	mainFrame.Visible = not mainFrame.Visible
	toggleUIButton.Text = mainFrame.Visible and "☰ Close Menu" or "☰ Open Menu"
	if mainFrame.Visible then
		updatePlayerList()
	end
end)

closeButton.MouseButton1Click:Connect(function()
	mainFrame.Visible = false
	toggleUIButton.Text = "☰ Open Menu"
end)

-- Auto hitbox toggle and remove all button
autoToggle.MouseButton1Click:Connect(function()
	autoHitboxEnabled = not autoHitboxEnabled
	autoToggle.Text = autoHitboxEnabled and "Auto Hitbox: ON" or "Auto Hitbox: OFF"
	autoToggle.BackgroundColor3 = autoHitboxEnabled and Color3.fromRGB(50, 180, 50) or Color3.fromRGB(180, 50, 50)
	if autoHitboxEnabled then
		-- Apply to all current players (except local)
		for _, player in pairs(Players:GetPlayers()) do
			if player ~= LocalPlayer then
				applyHeadHitboxForPlayer(player, tonumber(sizeInput.Text) or DEFAULT_HITBOX_SIZE)
			end
		end
	else
		-- Remove hitboxes for everyone
		for player, _ in pairs(hitboxData) do
			removeHeadHitboxForPlayer(player)
		end
	end
	-- Update status label
	statusLabel.Text = "Processing: " .. tableCount(hitboxData) .. " Players"
end)

removeAllBtn.MouseButton1Click:Connect(function()
	for player, _ in pairs(hitboxData) do
		removeHeadHitboxForPlayer(player)
	end
	statusLabel.Text = "Processing: 0 Players"
end)

-- Auto name ESP toggle
nameESPEnabled = false
autoNameESP.MouseButton1Click:Connect(function()
	nameESPEnabled = not nameESPEnabled
	autoNameESP.Text = nameESPEnabled and "Auto ESP Name: ON" or "Auto ESP Name: OFF"
	autoNameESP.BackgroundColor3 = nameESPEnabled and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(50, 150, 200)
	if not nameESPEnabled then
		for player, _ in pairs(nameESPObjects) do
			removeNameESP(player)
		end
	else
		for player, selected in pairs(selectedPlayers) do
			if selected and player.Character then
				createNameESP(player, player.Character)
			end
		end
	end
end)

refreshBtn.MouseButton1Click:Connect(function()
	updatePlayerList()
end)

-- ESP Name All toggle
local espNameAllState = false
espNameAllBtn.MouseButton1Click:Connect(function()
	espNameAllState = not espNameAllState
	espNameAllBtn.Text = espNameAllState and "ESP Name All: ON" or "ESP Name All: OFF"
	espNameAllBtn.BackgroundColor3 = espNameAllState and Color3.fromRGB(80, 220, 80) or Color3.fromRGB(80, 200, 80)
	for _, player in pairs(Players:GetPlayers()) do
		if player ~= LocalPlayer then
			selectedPlayers[player] = espNameAllState
			if espNameAllState and player.Character then
				createNameESP(player, player.Character)
			else
				removeNameESP(player)
			end
		end
	end
	updatePlayerList()
end)

-- Box ESP toggle
boxESPBtn.MouseButton1Click:Connect(function()
	boxESPEnabled = not boxESPEnabled
	boxESPBtn.Text = boxESPEnabled and "ESP Box Charm: ON" or "ESP Box Charm: OFF"
	boxESPBtn.BackgroundColor3 = boxESPEnabled and Color3.fromRGB(220, 220, 80) or Color3.fromRGB(200, 200, 80)
	for _, player in pairs(Players:GetPlayers()) do
		if player ~= LocalPlayer and player.Character then
			local color = getTeamColor(player)
			local size = tonumber(sizeInput.Text) or DEFAULT_HITBOX_SIZE
			local head = player.Character:FindFirstChild("Head")
			if boxESPEnabled then
				if head and head:IsA("BasePart") then
					local existing = head:FindFirstChild("BoxCharmESP")
					if existing then existing:Destroy() end
					local box = Instance.new("BoxHandleAdornment")
					box.Name = "BoxCharmESP"
					box.Adornee = head
					box.Size = Vector3.new(size, size, size)
					box.Color3 = color
					box.Transparency = ESP_TRANSPARENCY
					box.ZIndex = 10
					box.AlwaysOnTop = true
					box.Parent = head
				end
			else
				if head then
					local existing = head:FindFirstChild("BoxCharmESP")
					if existing then pcall(function() existing:Destroy() end) end
				end
			end
		end
	end
end)

-- Invisibility Button logic
invisButton.MouseButton1Click:Connect(toggleInvisibility)

UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then return end
	if input.KeyCode == INVIS_CONFIG.TOGGLE_KEY then
		toggleInvisibility()
	end
end)

LocalPlayer.CharacterAdded:Connect(function(character)
	-- Reset invisibility and cleanup chair
	isInvisible = false
	invisButton.BackgroundColor3 = INVIS_CONFIG.PRIMARY_COLOR
	invisButton.Text = "INVISIBLE"
	local invisChair = workspace:FindFirstChild("invischair")
	if invisChair then
		invisChair:Destroy()
	end
	setCharacterTransparency(character, 0)

	-- Ensure local loopspeed applied if enabled
	if loopspeedEnabled then
		task.wait(0.1)
		setLoopspeedEnabled(true)
	end
end)

Players.PlayerRemoving:Connect(function(leavingPlayer)
	if leavingPlayer == LocalPlayer then
		local invisChair = workspace:FindFirstChild("invischair")
		if invisChair then
			invisChair:Destroy()
		end
	end
	-- remove any hitbox data for leaving player
	if hitboxData[leavingPlayer] then
		removeHeadHitboxForPlayer(leavingPlayer)
	end
	removeNameESP(leavingPlayer)
end)

-- Ensure we handle existing players and new players
for _, player in ipairs(Players:GetPlayers()) do
	if player ~= LocalPlayer then
		handlePlayer(player)
	end
end

Players.PlayerAdded:Connect(function(player)
	if player ~= LocalPlayer then
		handlePlayer(player)
	end
end)

-- Update status label periodically
spawn(function()
	while true do
		pcall(function()
			statusLabel.Text = "Processing: " .. tableCount(hitboxData) .. " Players"
		end)
		task.wait(1)
	end
end)

-- End of file