-- Optimized Mobile ESP + HeadHitbox + FullBright + NoFog
-- Tối ưu: gom update vào 1 Heartbeat loop, reuse adornments, hạn chế reconnects
-- Ngôn ngữ: Vietnamese comments for clarity

-- SERVICES
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")
local UserInputService = game:GetService("UserInputService")
local Lighting = game:GetService("Lighting")
local LocalPlayer = Players.LocalPlayer

-- CONFIG
local DEFAULT_HITBOX_SIZE = 4
local ESP_COLOR = Color3.fromRGB(255, 150, 150)
local ESP_TRANSPARENCY = 0.7
local TEXT_ESP_COLOR = Color3.fromRGB(255, 255, 255)

local INVIS_CONFIG = {
    TOGGLE_KEY = Enum.KeyCode.C,
    SOUND_ID = "rbxassetid://942127495",
    INVISIBILITY_POSITION = Vector3.new(-25.95, 84, 3537.55),
    NOTIFICATION_DURATION = 3,
    BACKGROUND_COLOR = Color3.fromRGB(25, 25, 25),
    PRIMARY_COLOR = Color3.fromRGB(0, 170, 255),
    SUCCESS_COLOR = Color3.fromRGB(46, 204, 113),
    TEXT_COLOR = Color3.fromRGB(255, 255, 255),
}

-- TUNABLE PERFORMANCE
local UPDATE_INTERVAL = 0.12           -- how often (s) the main ESP update runs (distance, name colors, etc.)
local HITBOX_MAINT_INTERVAL = 2        -- how often (s) to repair/ensure head hitboxes (slower to save perf)
local MAX_NAMEESP_DISTANCE = 1000      -- max studs to show name ESP
local MAX_PLAYERS_PER_CYCLE = 60       -- safety cap when iterating players (minor perf guard)

-- STATE
local processedPlayers = {}            -- char -> true
local playerData = {}                  -- char/player keyed info (mesh backups, original sizes)
local boxESPObjects = {}               -- char -> BoxHandleAdornment (visual)
local nameESPObjects = {}              -- player -> {billboard, nameLabel, distanceLabel}
local globalConnections = {}           -- store connections to disconnect on cleanup

local autoHitboxEnabled = false
local nameESPEnabled = false
local boxESPEnabled = false
local selectedPlayers = {}
local espNameAllState = false

-- Invisibility State
local isInvisible = false
local invisButton
local invisSound

-- Lighting original states
local lightingBackup = {
    Ambient = Lighting.Ambient,
    Brightness = Lighting.Brightness,
    ClockTime = Lighting.ClockTime,
    GlobalShadows = Lighting.GlobalShadows,
    FogStart = Lighting.FogStart,
    FogEnd = Lighting.FogEnd,
    FogColor = Lighting.FogColor,
}

local fullBrightEnabled = false
local noFogEnabled = false

-- Helper functions
local function tableCount(t)
    local count = 0
    for _ in t do count = count + 1 end
    return count
end

local function getTeamColor(player)
    if player and player.Team and player.Team.TeamColor then
        return player.Team.TeamColor.Color
    end
    return ESP_COLOR
end

local function createNotification(title, text)
    pcall(function()
        StarterGui:SetCore("SendNotification", {
            Title = title,
            Text = text,
            Duration = INVIS_CONFIG.NOTIFICATION_DURATION,
        })
    end)
end

local function setCharacterTransparency(character, transparency)
    if not character then return end
    for _, descendant in character:GetDescendants() do
        if descendant:IsA("BasePart") or descendant:IsA("Decal") then
            -- only affect parts that appear to be character visuals
            if descendant.Name ~= "HumanoidRootPart" then
                descendant.Transparency = transparency
            else
                descendant.Transparency = transparency
            end
        end
    end
end

local function getHumanoidRootPart()
    local character = LocalPlayer.Character
    if not character then return nil end
    return character:FindFirstChild("HumanoidRootPart")
end

local function playInvisSound()
    if invisSound then
        pcall(function() invisSound:Play() end)
    end
end

local function isAlive(character)
    if not character then return false end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return false end
    return humanoid.Health > 0
end

-- Invisibility handling (kept mostly same, but cleaned a bit)
local function toggleInvisibility()
    if not LocalPlayer.Character then return end
    isInvisible = not isInvisible
    playInvisSound()
    if isInvisible then
        local humanoidRootPart = getHumanoidRootPart()
        if not humanoidRootPart then warn("HumanoidRootPart not found") return end
        local savedCFrame = humanoidRootPart.CFrame
        LocalPlayer.Character:MoveTo(INVIS_CONFIG.INVISIBILITY_POSITION)
        task.wait(0.12)

        -- create invisible seat once
        local seat = Instance.new("Seat")
        seat.Name = "invischair"
        seat.Anchored = false
        seat.CanCollide = false
        seat.Transparency = 1
        seat.Size = Vector3.new(2, 0.5, 2)
        seat.CFrame = INVIS_CONFIG.INVISIBILITY_POSITION
        seat.Parent = workspace

        local weld = Instance.new("Weld")
        weld.Part0 = seat
        weld.Part1 = humanoidRootPart
        weld.Parent = seat

        task.wait()
        seat.CFrame = savedCFrame

        setCharacterTransparency(LocalPlayer.Character, 0.5)

        if invisButton then
            invisButton.BackgroundColor3 = INVIS_CONFIG.SUCCESS_COLOR
            invisButton.Text = "VISIBLE"
        end
        createNotification("Invisibility ON", "You are now invisible")
    else
        local invisChair = workspace:FindFirstChild("invischair")
        if invisChair then invisChair:Destroy() end
        if LocalPlayer.Character then setCharacterTransparency(LocalPlayer.Character, 0) end
        if invisButton then
            invisButton.BackgroundColor3 = INVIS_CONFIG.PRIMARY_COLOR
            invisButton.Text = "INVISIBLE"
        end
        createNotification("Invisibility OFF", "You are now visible")
    end
end

-- Box ESP / Hitbox functions (optimized: reuse adornments & backup data)
local function createOrGetBox(char, size, color)
    if not char then return nil end
    local head = char:FindFirstChild("Head")
    if not head then return nil end

    if boxESPObjects[char] and boxESPObjects[char].Parent then
        -- reuse
        local box = boxESPObjects[char]
        box.Size = Vector3.new(size, size, size)
        box.Color3 = color
        box.Transparency = ESP_TRANSPARENCY
        return box
    end

    -- Make sure to not create duplicate children in Head
    for _, child in ipairs(head:GetChildren()) do
        if child:IsA("BoxHandleAdornment") and child.Name == "BoxCharmESP" then
            child:Destroy()
        end
    end

    local box = Instance.new("BoxHandleAdornment")
    box.Name = "BoxCharmESP"
    box.Adornee = head
    box.Size = Vector3.new(size, size, size)
    box.Color3 = color
    box.Transparency = ESP_TRANSPARENCY
    box.ZIndex = 10
    box.AlwaysOnTop = true
    box.Parent = head
    boxESPObjects[char] = box
    return box
end

local function removeBoxESP(character)
    if not character then return end
    if boxESPObjects[character] then
        if boxESPObjects[character].Parent then
            boxESPObjects[character]:Destroy()
        end
        boxESPObjects[character] = nil
    end
    local head = character:FindFirstChild("Head")
    if head then
        for _, child in ipairs(head:GetChildren()) do
            if child:IsA("BoxHandleAdornment") and child.Name == "BoxCharmESP" then
                child:Destroy()
            end
        end
    end
end

local function removeHeadHitbox(character)
    if not character then return end
    local head = character:FindFirstChild("Head")
    removeBoxESP(character)
    if head then
        if head:FindFirstChild("OriginalSize") then
            head.Size = head.OriginalSize.Value
            head.OriginalSize:Destroy()
        end
        if playerData[character] and playerData[character].meshBackup then
            -- put back mesh if needed
            if playerData[character].meshBackup and playerData[character].meshBackup.Parent == nil then
                playerData[character].meshBackup.Parent = head
            end
        end
        head.Transparency = 0
        head.CanCollide = true
        head.Material = Enum.Material.Plastic
    end
    processedPlayers[character] = nil
end

local function applyHeadHitbox(character, size)
    if not character then return end
    if not isAlive(character) then return end
    if processedPlayers[character] then return end

    local head = character:FindFirstChild("Head")
    if not head then return end

    -- backup original size once
    if not head:FindFirstChild("OriginalSize") then
        local original = Instance.new("Vector3Value")
        original.Name = "OriginalSize"
        original.Value = head.Size
        original.Parent = head
    end

    -- backup mesh once per character
    if head:FindFirstChild("Mesh") then
        playerData[character] = playerData[character] or {}
        if not playerData[character].meshBackup then
            -- clone and keep detached to restore later
            local ok, clone = pcall(function() return head.Mesh:Clone() end)
            if ok and clone then
                playerData[character].meshBackup = clone
                clone.Parent = nil
            end
            head.Mesh:Destroy()
        end
    end

    head.Massless = true
    head.Size = Vector3.new(size, size, size)
    head.CanCollide = false
    head.Transparency = 0.5
    head.Material = Enum.Material.ForceField

    createOrGetBox(character, size, ESP_COLOR)

    processedPlayers[character] = true
end

-- UI helpers (unchanged layout but added FullBright/NoFog toggles)
local function createTransparentButton(text, color, parent)
    local btn = Instance.new("TextButton")
    btn.Size = UDim2.new(1, 0, 0, 32)
    btn.Text = text
    btn.BackgroundColor3 = color
    btn.BackgroundTransparency = 0.7
    btn.TextColor3 = Color3.new(1, 1, 1)
    btn.Font = Enum.Font.Gotham
    btn.TextSize = 14
    btn.BorderSizePixel = 0
    btn.Parent = parent
    local btnCorner = Instance.new("UICorner")
    btnCorner.CornerRadius = UDim.new(0, 4)
    btnCorner.Parent = btn
    return btn
end

local function createTransparentInput(placeholder, text, parent)
    local input = Instance.new("TextBox")
    input.Size = UDim2.new(1, 0, 0, 32)
    input.PlaceholderText = placeholder
    input.Text = text
    input.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    input.BackgroundTransparency = 0.7
    input.TextColor3 = Color3.new(1, 1, 1)
    input.Font = Enum.Font.Gotham
    input.TextSize = 14
    input.BorderSizePixel = 0
    input.Parent = parent
    local inputCorner = Instance.new("UICorner")
    inputCorner.CornerRadius = UDim.new(0, 4)
    inputCorner.Parent = input
    return input
end

local function createTransparentLabel(text, parent)
    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1, 0, 0, 22)
    label.BackgroundTransparency = 1
    label.Text = text
    label.TextColor3 = Color3.fromRGB(200, 200, 200)
    label.Font = Enum.Font.Gotham
    label.TextSize = 12
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.Parent = parent
    return label
end

-- UI SETUP (kept mostly same, add two buttons)
local gui = Instance.new("ScreenGui")
gui.Name = "Mobile_ESP_GUI_Fixed"
gui.ResetOnSpawn = false
gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
if LocalPlayer:FindFirstChild("PlayerGui") then
    local oldGui = LocalPlayer.PlayerGui:FindFirstChild("Mobile_ESP_GUI_Fixed")
    if oldGui then oldGui:Destroy() end
end
gui.Parent = LocalPlayer:WaitForChild("PlayerGui")

local mainContainer = Instance.new("Frame")
mainContainer.Size = UDim2.new(0, 220, 0, 36)
mainContainer.Position = UDim2.new(0.5, -110, 0, 10)
mainContainer.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
mainContainer.BackgroundTransparency = 0.7
mainContainer.BorderSizePixel = 0
mainContainer.Active = true
mainContainer.Draggable = true
mainContainer.Parent = gui
local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0, 8)
corner.Parent = mainContainer

local toggleUIButton = Instance.new("TextButton")
toggleUIButton.Size = UDim2.new(0, 110, 0, 28)
toggleUIButton.Position = UDim2.new(0.5, -55, 0.5, -14)
toggleUIButton.Text = "☰ Open Menu"
toggleUIButton.TextColor3 = Color3.fromRGB(255, 255, 255)
toggleUIButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
toggleUIButton.BackgroundTransparency = 0.7
toggleUIButton.BorderSizePixel = 0
toggleUIButton.Font = Enum.Font.Gotham
toggleUIButton.TextSize = 14
toggleUIButton.Parent = mainContainer
local buttonCorner = Instance.new("UICorner")
buttonCorner.CornerRadius = UDim.new(0, 6)
buttonCorner.Parent = toggleUIButton

local mainFrame = Instance.new("Frame")
mainFrame.Size = UDim2.new(0, 220, 0, 380)
mainFrame.Position = UDim2.new(0.5, -110, 0.5, -190)
mainFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
mainFrame.BackgroundTransparency = 0.7
mainFrame.BorderSizePixel = 0
mainFrame.Visible = false
mainFrame.Active = true
mainFrame.Draggable = true
mainFrame.Parent = gui
local mainCorner = Instance.new("UICorner")
mainCorner.CornerRadius = UDim.new(0, 8)
mainCorner.Parent = mainFrame

-- Tab Bar
local tabBar = Instance.new("Frame")
tabBar.Size = UDim2.new(1, 0, 0, 32)
tabBar.Position = UDim2.new(0, 0, 0, 0)
tabBar.BackgroundTransparency = 1
tabBar.Parent = mainFrame

local tab1Btn = Instance.new("TextButton")
tab1Btn.Size = UDim2.new(0.5, -2, 1, 0)
tab1Btn.Position = UDim2.new(0, 0, 0, 0)
tab1Btn.Text = "HeadHitbox"
tab1Btn.TextColor3 = Color3.fromRGB(255, 255, 255)
tab1Btn.BackgroundColor3 = Color3.fromRGB(220, 60, 60)
tab1Btn.BackgroundTransparency = 0.2
tab1Btn.Font = Enum.Font.GothamBold
tab1Btn.TextSize = 14
tab1Btn.BorderSizePixel = 0
tab1Btn.Parent = tabBar
local tab1Corner = Instance.new("UICorner")
tab1Corner.CornerRadius = UDim.new(0, 6)
tab1Corner.Parent = tab1Btn

local tab2Btn = Instance.new("TextButton")
tab2Btn.Size = UDim2.new(0.5, -2, 1, 0)
tab2Btn.Position = UDim2.new(0.5, 2, 0, 0)
tab2Btn.Text = "Other"
tab2Btn.TextColor3 = Color3.fromRGB(255, 255, 255)
tab2Btn.BackgroundColor3 = Color3.fromRGB(60, 120, 220)
tab2Btn.BackgroundTransparency = 0.2
tab2Btn.Font = Enum.Font.GothamBold
tab2Btn.TextSize = 14
tab2Btn.BorderSizePixel = 0
tab2Btn.Parent = tabBar
local tab2Corner = Instance.new("UICorner")
tab2Corner.CornerRadius = UDim.new(0, 6)
tab2Corner.Parent = tab2Btn

-- Tab Panels
local leftPanel = Instance.new("Frame")
leftPanel.Size = UDim2.new(1, -12, 1, -44)
leftPanel.Position = UDim2.new(0, 6, 0, 38)
leftPanel.BackgroundTransparency = 1
leftPanel.BorderSizePixel = 0
leftPanel.Visible = true
leftPanel.Parent = mainFrame

local rightPanel = Instance.new("ScrollingFrame")
rightPanel.Size = UDim2.new(1, -12, 1, -44)
rightPanel.Position = UDim2.new(0, 6, 0, 38)
rightPanel.BackgroundTransparency = 1
rightPanel.BorderSizePixel = 0
rightPanel.ScrollBarThickness = 4
rightPanel.CanvasSize = UDim2.new(0, 0, 0, 0)
rightPanel.Visible = false
rightPanel.Parent = mainFrame

local leftLayout = Instance.new("UIListLayout")
leftLayout.Parent = leftPanel
leftLayout.SortOrder = Enum.SortOrder.LayoutOrder
leftLayout.Padding = UDim.new(0, 4)

local rightLayout = Instance.new("UIListLayout")
rightLayout.Parent = rightPanel
rightLayout.SortOrder = Enum.SortOrder.LayoutOrder
rightLayout.Padding = UDim.new(0, 4)

-- Left (HeadHitbox)
local leftTitle = createTransparentLabel("Head hitbox", leftPanel)
leftTitle.TextColor3 = Color3.fromRGB(255, 150, 150)
leftTitle.Font = Enum.Font.GothamBold
leftTitle.TextSize = 14

local sizeInput = createTransparentInput("Size (e.g. 4)", tostring(DEFAULT_HITBOX_SIZE), leftPanel)
local autoToggle = createTransparentButton("Auto Hitbox: OFF", Color3.fromRGB(180, 50, 50), leftPanel)
local removeAllBtn = createTransparentButton("Remove All Hitboxes", Color3.fromRGB(180, 50, 50), leftPanel)
local statusLabel = createTransparentLabel("Processing: 0 Players", leftPanel)
local loopspeedLabel = createTransparentLabel("Loopspeed (WalkSpeed)", leftPanel)
local loopspeedInput = createTransparentInput("Speed (e.g. 16)", "16", leftPanel)
local loopspeedToggle = createTransparentButton("Loopspeed: OFF", Color3.fromRGB(80, 80, 200), leftPanel)
invisButton = createTransparentButton("INVISIBLE", INVIS_CONFIG.PRIMARY_COLOR, leftPanel)

invisSound = Instance.new("Sound")
invisSound.Name = "ToggleSound"
invisSound.SoundId = INVIS_CONFIG.SOUND_ID
invisSound.Volume = 0.5
invisSound.Parent = gui

-- Right (ESP & Extra)
local rightTitle = createTransparentLabel("ESP & Other Features", rightPanel)
rightTitle.TextColor3 = Color3.fromRGB(150, 200, 255)
rightTitle.Font = Enum.Font.GothamBold
rightTitle.TextSize = 14

local playerList = Instance.new("ScrollingFrame")
playerList.Size = UDim2.new(1, 0, 0, 110)
playerList.BackgroundTransparency = 1
playerList.BorderSizePixel = 0
playerList.ScrollBarThickness = 4
playerList.CanvasSize = UDim2.new(0, 0, 0, 0)
playerList.Parent = rightPanel
local playerListLayout = Instance.new("UIListLayout")
playerListLayout.Parent = playerList
playerListLayout.SortOrder = Enum.SortOrder.LayoutOrder
playerListLayout.Padding = UDim.new(0, 2)

local autoNameESP = createTransparentButton("Auto ESP Name: OFF", Color3.fromRGB(50, 150, 200), rightPanel)
local refreshBtn = createTransparentButton("Refresh Player List", Color3.fromRGB(80, 80, 180), rightPanel)
local espNameAllBtn = createTransparentButton("ESP Name All: OFF", Color3.fromRGB(80, 200, 80), rightPanel)
local boxESPBtn = createTransparentButton("ESP Box Charm: OFF", Color3.fromRGB(200, 200, 80), rightPanel)
local fullBrightBtn = createTransparentButton("FullBright: OFF", Color3.fromRGB(200, 120, 200), rightPanel)
local noFogBtn = createTransparentButton("NoFog: OFF", Color3.fromRGB(150, 150, 150), rightPanel)

local function switchTab(tabIndex)
    if tabIndex == 1 then
        leftPanel.Visible = true
        rightPanel.Visible = false
        tab1Btn.BackgroundTransparency = 0.2
        tab2Btn.BackgroundTransparency = 0.6
    else
        leftPanel.Visible = false
        rightPanel.Visible = true
        tab1Btn.BackgroundTransparency = 0.6
        tab2Btn.BackgroundTransparency = 0.2
    end
end

tab1Btn.MouseButton1Click:Connect(function() switchTab(1) end)
tab2Btn.MouseButton1Click:Connect(function() switchTab(2) end)
switchTab(1)

local closeButton = Instance.new("TextButton")
closeButton.Size = UDim2.new(0, 28, 0, 28)
closeButton.Position = UDim2.new(1, -32, 0, 2)
closeButton.Text = "X"
closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
closeButton.BackgroundTransparency = 1
closeButton.BorderSizePixel = 0
closeButton.Font = Enum.Font.GothamBold
closeButton.TextSize = 16
closeButton.Parent = mainFrame

-- NAME ESP (now: create minimal billboard and let main loop update)
local function createNameESP(player, char)
    if not player or player == LocalPlayer then return end
    if not char then return end
    local head = char:FindFirstChild("Head")
    if not head then return end

    removeNameESP(player) -- ensure none exists

    local billboard = Instance.new("BillboardGui")
    billboard.Name = "NameESP"
    billboard.Adornee = head
    billboard.Size = UDim2.new(0, 200, 0, 50)
    billboard.StudsOffset = Vector3.new(0, 2.5, 0)
    billboard.AlwaysOnTop = true
    billboard.MaxDistance = MAX_NAMEESP_DISTANCE
    billboard.Parent = head

    local nameLabel = Instance.new("TextLabel")
    nameLabel.Name = "ESPName"
    nameLabel.Size = UDim2.new(1, 0, 0.5, 0)
    nameLabel.Position = UDim2.new(0, 0, 0, 0)
    nameLabel.BackgroundTransparency = 1
    nameLabel.Text = player.Name
    nameLabel.TextColor3 = getTeamColor(player)
    nameLabel.TextStrokeTransparency = 0
    nameLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
    nameLabel.Font = Enum.Font.GothamBold
    nameLabel.TextSize = 14
    nameLabel.Parent = billboard

    local distanceLabel = Instance.new("TextLabel")
    distanceLabel.Name = "ESPDist"
    distanceLabel.Size = UDim2.new(1, 0, 0.5, 0)
    distanceLabel.Position = UDim2.new(0, 0, 0.5, 0)
    distanceLabel.BackgroundTransparency = 1
    distanceLabel.Text = "0m"
    distanceLabel.TextColor3 = TEXT_ESP_COLOR
    distanceLabel.TextStrokeTransparency = 0
    distanceLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
    distanceLabel.Font = Enum.Font.Gotham
    distanceLabel.TextSize = 12
    distanceLabel.Parent = billboard

    nameESPObjects[player] = {
        billboard = billboard,
        nameLabel = nameLabel,
        distanceLabel = distanceLabel,
        head = head
    }
end

function removeNameESP(player)
    if nameESPObjects[player] then
        local obj = nameESPObjects[player]
        if obj.billboard and obj.billboard.Parent then
            obj.billboard:Destroy()
        end
        nameESPObjects[player] = nil
    end
end

-- Handle player character lifecycle and cleanup
local function handleCharacter(player, char)
    if not player or player == LocalPlayer then return end
    task.spawn(function()
        task.wait(0.5)
        local humanoid = char:FindFirstChildOfClass("Humanoid") or char:WaitForChild("Humanoid", 5)
        if humanoid then
            humanoid.Died:Connect(function()
                -- cleanup visual things on death
                removeHeadHitbox(char)
                removeBoxESP(char)
                removeNameESP(player)
            end)
        end

        if autoHitboxEnabled and isAlive(char) then
            applyHeadHitbox(char, tonumber(sizeInput.Text) or DEFAULT_HITBOX_SIZE)
        end

        if espNameAllState then
            selectedPlayers[player] = true
            createNameESP(player, char)
        elseif nameESPEnabled and selectedPlayers[player] then
            createNameESP(player, char)
        end

        if boxESPEnabled and isAlive(char) then
            local color = getTeamColor(player)
            local size = tonumber(sizeInput.Text) or DEFAULT_HITBOX_SIZE
            createOrGetBox(char, size, color)
        end

        -- when character removed from world, cleanup
        char.AncestryChanged:Connect(function(_, parent)
            if not parent then
                removeHeadHitbox(char)
                removeBoxESP(char)
                removeNameESP(player)
            end
        end)
    end)
end

local function handlePlayer(player)
    if not player then return end
    if player == LocalPlayer then return end

    -- connect character added
    local charConn = player.CharacterAdded:Connect(function(char) handleCharacter(player, char) end)
    table.insert(globalConnections, charConn)
    if player.Character then
        handleCharacter(player, player.Character)
    end

    -- cleanup on leave
    local leaveConn = player.AncestryChanged:Connect(function(_, parent)
        if not parent then
            if player.Character then
                removeHeadHitbox(player.Character)
                removeBoxESP(player.Character)
            end
            removeNameESP(player)
            selectedPlayers[player] = nil
        end
    end)
    table.insert(globalConnections, leaveConn)
end

-- Player list UI update
local function updatePlayerList()
    for _, child in pairs(playerList:GetChildren()) do
        if child:IsA("TextButton") then child:Destroy() end
    end
    local yPos = 0
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            local playerBtn = Instance.new("TextButton")
            playerBtn.Size = UDim2.new(1, -6, 0, 28)
            playerBtn.Text = player.Name
            playerBtn.BackgroundColor3 = selectedPlayers[player] and Color3.fromRGB(80, 160, 80) or Color3.fromRGB(60, 60, 60)
            playerBtn.BackgroundTransparency = 0.7
            playerBtn.TextColor3 = Color3.new(1, 1, 1)
            playerBtn.Font = Enum.Font.Gotham
            playerBtn.TextSize = 14
            playerBtn.BorderSizePixel = 0
            playerBtn.Parent = playerList
            local btnCorner = Instance.new("UICorner")
            btnCorner.CornerRadius = UDim.new(0, 4)
            btnCorner.Parent = playerBtn
            playerBtn.MouseButton1Click:Connect(function()
                selectedPlayers[player] = not selectedPlayers[player]
                playerBtn.BackgroundColor3 = selectedPlayers[player] and Color3.fromRGB(80, 160, 80) or Color3.fromRGB(60, 60, 60)
                if nameESPEnabled then
                    if selectedPlayers[player] and player.Character and isAlive(player.Character) then
                        createNameESP(player, player.Character)
                    else
                        removeNameESP(player)
                    end
                end
            end)
            yPos = yPos + 30
        end
    end
    playerList.CanvasSize = UDim2.new(0, 0, 0, yPos)
end

-- Loopspeed (walkspeed) control
local loopspeedEnabled = false
local loopspeedConnection = nil
local function setLoopspeedEnabled(state)
    loopspeedEnabled = state
    loopspeedToggle.Text = loopspeedEnabled and "Loopspeed: ON" or "Loopspeed: OFF"
    loopspeedToggle.BackgroundColor3 = loopspeedEnabled and Color3.fromRGB(80, 200, 80) or Color3.fromRGB(80, 80, 200)
    if loopspeedConnection then
        loopspeedConnection:Disconnect()
        loopspeedConnection = nil
    end
    if loopspeedEnabled then
        loopspeedConnection = RunService.Heartbeat:Connect(function()
            local character = LocalPlayer.Character
            if character then
                local humanoid = character:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    local speedValue = tonumber(loopspeedInput.Text) or 16
                    humanoid.WalkSpeed = speedValue
                end
            end
        end)
    else
        local character = LocalPlayer.Character
        if character then
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid.WalkSpeed = 16
            end
        end
    end
end

-- FullBright / NoFog toggles -- store & restore original values
local function setFullBright(state)
    fullBrightEnabled = state
    fullBrightBtn.Text = fullBrightEnabled and "FullBright: ON" or "FullBright: OFF"
    fullBrightBtn.BackgroundColor3 = fullBrightEnabled and Color3.fromRGB(120, 200, 120) or Color3.fromRGB(200, 120, 200)
    if fullBrightEnabled then
        -- apply "fullbright-ish"
        lightingBackup.Ambient = Lighting.Ambient
        lightingBackup.Brightness = Lighting.Brightness
        lightingBackup.GlobalShadows = Lighting.GlobalShadows
        Lighting.Ambient = Color3.fromRGB(255,255,255)
        Lighting.Brightness = 2
        Lighting.GlobalShadows = false
    else
        -- restore
        Lighting.Ambient = lightingBackup.Ambient or Color3.fromRGB(128,128,128)
        Lighting.Brightness = lightingBackup.Brightness or 1
        Lighting.GlobalShadows = lightingBackup.GlobalShadows ~= nil and lightingBackup.GlobalShadows or true
    end
end

local function setNoFog(state)
    noFogEnabled = state
    noFogBtn.Text = noFogEnabled and "NoFog: ON" or "NoFog: OFF"
    noFogBtn.BackgroundColor3 = noFogEnabled and Color3.fromRGB(120, 200, 120) or Color3.fromRGB(150, 150, 150)
    if noFogEnabled then
        lightingBackup.FogStart = Lighting.FogStart
        lightingBackup.FogEnd = Lighting.FogEnd
        lightingBackup.FogColor = Lighting.FogColor
        Lighting.FogStart = 0
        Lighting.FogEnd = 1e6
    else
        Lighting.FogStart = lightingBackup.FogStart or 0
        Lighting.FogEnd = lightingBackup.FogEnd or 100000
        Lighting.FogColor = lightingBackup.FogColor or Color3.fromRGB(255,255,255)
    end
end

-- UI interactions
loopspeedToggle.MouseButton1Click:Connect(function() setLoopspeedEnabled(not loopspeedEnabled) end)
loopspeedInput.FocusLost:Connect(function() if loopspeedEnabled then setLoopspeedEnabled(true) end end)

toggleUIButton.MouseButton1Click:Connect(function()
    mainFrame.Visible = not mainFrame.Visible
    toggleUIButton.Text = mainFrame.Visible and "☰ Close Menu" or "☰ Open Menu"
    if mainFrame.Visible then updatePlayerList() end
end)
closeButton.MouseButton1Click:Connect(function() mainFrame.Visible = false toggleUIButton.Text = "☰ Open Menu" end)

autoToggle.MouseButton1Click:Connect(function()
    autoHitboxEnabled = not autoHitboxEnabled
    autoToggle.Text = autoHitboxEnabled and "Auto Hitbox: ON" or "Auto Hitbox: OFF"
    autoToggle.BackgroundColor3 = autoHitboxEnabled and Color3.fromRGB(50, 180, 50) or Color3.fromRGB(180, 50, 50)
    if autoHitboxEnabled then
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character and isAlive(player.Character) then
                applyHeadHitbox(player.Character, tonumber(sizeInput.Text) or DEFAULT_HITBOX_SIZE)
            end
        end
    else
        for character, _ in pairs(processedPlayers) do
            removeHeadHitbox(character)
        end
    end
    statusLabel.Text = "Processing: " .. tableCount(processedPlayers) .. " Players"
end)

removeAllBtn.MouseButton1Click:Connect(function()
    for character, _ in pairs(processedPlayers) do
        removeHeadHitbox(character)
    end
    statusLabel.Text = "Processing: 0 Players"
end)

autoNameESP.MouseButton1Click:Connect(function()
    nameESPEnabled = not nameESPEnabled
    autoNameESP.Text = nameESPEnabled and "Auto ESP Name: ON" or "Auto ESP Name: OFF"
    autoNameESP.BackgroundColor3 = nameESPEnabled and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(50, 150, 200)
    if not nameESPEnabled then
        for player, _ in pairs(nameESPObjects) do removeNameESP(player) end
    else
        for player, selected in pairs(selectedPlayers) do
            if selected and player.Character and isAlive(player.Character) then createNameESP(player, player.Character) end
        end
    end
end)

refreshBtn.MouseButton1Click:Connect(updatePlayerList)

espNameAllBtn.MouseButton1Click:Connect(function()
    espNameAllState = not espNameAllState
    espNameAllBtn.Text = espNameAllState and "ESP Name All: ON" or "ESP Name All: OFF"
    espNameAllBtn.BackgroundColor3 = espNameAllState and Color3.fromRGB(80, 220, 80) or Color3.fromRGB(80, 200, 80)
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            selectedPlayers[player] = espNameAllState
            if espNameAllState and player.Character and isAlive(player.Character) then
                createNameESP(player, player.Character)
            else
                removeNameESP(player)
            end
        end
    end
    updatePlayerList()
end)

boxESPBtn.MouseButton1Click:Connect(function()
    boxESPEnabled = not boxESPEnabled
    boxESPBtn.Text = boxESPEnabled and "ESP Box Charm: ON" or "ESP Box Charm: OFF"
    boxESPBtn.BackgroundColor3 = boxESPEnabled and Color3.fromRGB(220, 220, 80) or Color3.fromRGB(200, 200, 80)
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and isAlive(player.Character) then
            local color = getTeamColor(player)
            local size = tonumber(sizeInput.Text) or DEFAULT_HITBOX_SIZE
            if boxESPEnabled then
                createOrGetBox(player.Character, size, color)
            else
                removeBoxESP(player.Character)
            end
        end
    end
end)

fullBrightBtn.MouseButton1Click:Connect(function()
    setFullBright(not fullBrightEnabled)
end)
noFogBtn.MouseButton1Click:Connect(function()
    setNoFog(not noFogEnabled)
end)

invisButton.MouseButton1Click:Connect(toggleInvisibility)
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == INVIS_CONFIG.TOGGLE_KEY then
        toggleInvisibility()
    end
end)

LocalPlayer.CharacterAdded:Connect(function(character)
    isInvisible = false
    if invisButton then
        invisButton.BackgroundColor3 = INVIS_CONFIG.PRIMARY_COLOR
        invisButton.Text = "INVISIBLE"
    end
    local invisChair = workspace:FindFirstChild("invischair")
    if invisChair then invisChair:Destroy() end
    setCharacterTransparency(character, 0)
end)

Players.PlayerAdded:Connect(function(player) handlePlayer(player) end)
Players.PlayerRemoving:Connect(function(player)
    if player == LocalPlayer then
         local invisChair = workspace:FindFirstChild("invischair")
         if invisChair then invisChair:Destroy() end
    end
    if player.Character then
        removeHeadHitbox(player.Character)
        removeBoxESP(player.Character)
    end
    removeNameESP(player)
    selectedPlayers[player] = nil
end)

for _, player in pairs(Players:GetPlayers()) do handlePlayer(player) end
updatePlayerList()

-- MAIN HEARTBEAT LOOP (single loop to reduce overhead)
do
    local accum = 0
    local hitboxAccum = 0
    RunService.Heartbeat:Connect(function(dt)
        accum = accum + dt
        hitboxAccum = hitboxAccum + dt

        -- Periodic visual updates (name distances, colors)
        if accum >= UPDATE_INTERVAL then
            accum = 0
            -- update name ESPs
            local localHead = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Head")
            for player, obj in pairs(nameESPObjects) do
                -- basic validation
                if not player or not player.Parent or not obj or not obj.head or not obj.head.Parent then
                    removeNameESP(player)
                else
                    if localHead and obj.head then
                        -- only update within max distance
                        local dist = (obj.head.Position - localHead.Position).Magnitude
                        if dist > MAX_NAMEESP_DISTANCE then
                            obj.billboard.Enabled = false
                        else
                            obj.billboard.Enabled = true
                            obj.distanceLabel.Text = string.format("%.1fm", dist)
                            -- update name color according to team
                            local teamColor = getTeamColor(player)
                            if obj.nameLabel.TextColor3 ~= teamColor then
                                obj.nameLabel.TextColor3 = teamColor
                            end
                        end
                    end
                end
            end
            -- update status label
            statusLabel.Text = "Processing: " .. tableCount(processedPlayers) .. " Players"
        end

        -- Slower hitbox maintenance to reduce perf cost
        if hitboxAccum >= HITBOX_MAINT_INTERVAL then
            hitboxAccum = 0
            if autoHitboxEnabled then
                -- iterate a bounded number of players to avoid giant spikes
                local count = 0
                for _, player in pairs(Players:GetPlayers()) do
                    if count >= MAX_PLAYERS_PER_CYCLE then break end
                    count = count + 1
                    if player ~= LocalPlayer and player.Character then
                        local char = player.Character
                        if isAlive(char) then
                            -- apply if missing
                            if not processedPlayers[char] then
                                applyHeadHitbox(char, tonumber(sizeInput.Text) or DEFAULT_HITBOX_SIZE)
                            else
                                -- repair visual box if missing
                                local head = char:FindFirstChild("Head")
                                if head then
                                    local found = false
                                    for _, c in ipairs(head:GetChildren()) do
                                        if c:IsA("BoxHandleAdornment") and c.Name == "BoxCharmESP" then found = true break end
                                    end
                                    if not found and boxESPEnabled then
                                        createOrGetBox(char, tonumber(sizeInput.Text) or DEFAULT_HITBOX_SIZE, getTeamColor(player))
                                    end
                                end
                            end
                        else
                            if processedPlayers[char] then
                                removeHeadHitbox(char)
                            end
                        end
                    end
                end
            end
        end

        -- Maintain FullBright/NoFog if needed (lightweight)
        if fullBrightEnabled then
            -- ensure GlobalShadows off (some games might toggle it)
            if Lighting.GlobalShadows ~= false then Lighting.GlobalShadows = false end
        end
        if noFogEnabled then
            if Lighting.FogEnd < 1e5 then Lighting.FogEnd = 1e6 end
        end
    end)
end

-- Final status init
statusLabel.Text = "Processing: " .. tableCount(processedPlayers) .. " Players"
updatePlayerList()
